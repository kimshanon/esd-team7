This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
atomic/
  customer.py
  Dockerfile.customer
  Dockerfile.order
  Dockerfile.payment
  Dockerfile.picker
  Dockerfile.stall
  order.py
  payment.py
  picker.py
  stall.py
composite/
  cancellation/
    cancellation.py
  refund/
    refund.py
  assign_picker_v2.py
  assign_picker.py
  calc_payment.py
  Dockerfile.calc_payment
  requirements.txt
  updatelocation.py
models/
  customer_model.py
  order_model.py
  picker_model.py
  stall_model.py
test/
  receive.py
  send.py
.env.docker
.gitignore
atomic_requirements.txt
composite_requirements.txt
customer.html
docker-compose.yml
firebase.json
package.json
picker.html
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="atomic/customer.py">
from flask import Flask, request, jsonify, abort, make_response
from flask_cors import CORS
import os
from dotenv import load_dotenv
import firebase_admin
from firebase_admin import credentials, firestore
from pydantic import ValidationError
from models.customer_model import CustomerModel

load_dotenv()  # Loads the .env file

# Initialize firebase
if not firebase_admin._apps:
    cred_path = os.getenv("FIREBASE_SERVICE_ACCOUNT_KEY_PATH")
    cred = credentials.Certificate(cred_path)
    firebase_admin.initialize_app(cred)

# Set DB
db = firestore.client()

app = Flask(__name__)
# Enable CORS for the specific frontend origin
CORS(app)

# Handle OPTIONS pre-flight CORS request
@app.route('/<path:path>', methods=['OPTIONS'])
@app.route('/', methods=['OPTIONS'])
def options_handler(path=None):
    return make_response('', 200)

# TEST endpoint
@app.route('/test', methods=['GET'])
def test():
    return "Customer MS is running"

# GET all customers
@app.route('/customers', methods=['GET'])
def get_customers():
    customers_ref = db.collection('customers')
    docs = customers_ref.stream()
    customers = []
    for doc in docs:
        data = doc.to_dict()
        data['id'] = doc.id
        customers.append(data)
    return jsonify(customers), 200

# GET a specific customer by document ID
@app.route('/customers/<customer_id>', methods=['GET'])
def get_customer(customer_id):
    doc_ref = db.collection('customers').document(customer_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Customer not found")
    customer = doc.to_dict()
    customer['id'] = doc.id
    return jsonify(customer), 200

# POST a new customer
@app.route('/customers', methods=['POST'])
def create_customer():
    data = request.get_json()
    if not data:
        abort(400, description="Missing request body")
    
    # Check if firebase_uid is provided
    if 'firebase_uid' not in data:
        abort(400, description="firebase_uid is required")
    
    firebase_uid = data['firebase_uid']
    
    # Check if customer already exists with this firebase_uid
    doc_ref = db.collection('customers').document(firebase_uid)
    if doc_ref.get().exists:
        abort(409, description="Customer with this Firebase UID already exists")
    
    try:
        # Validate data using Pydantic model
        customer_data = CustomerModel(**data)
        
        # Use the firebase_uid as the document ID
        doc_ref.set(customer_data.to_dict())
        
        # Return the new customer with its ID
        new_customer = customer_data.to_dict()
        new_customer['id'] = firebase_uid
        return jsonify(new_customer), 201
        
    except ValidationError as e:
        return jsonify({"error": str(e)}), 400

# PUT update an existing customer
@app.route('/customers/<customer_id>', methods=['PUT'])
def update_customer(customer_id):
    data = request.json
    if not data:
        abort(400, description="Missing request body")
    
    doc_ref = db.collection('customers').document(customer_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Customer not found")
    
    # Get current data and update with new data
    current_data = doc.to_dict()
    
    # Don't allow changing firebase_uid
    if 'firebase_uid' in data and data['firebase_uid'] != customer_id:
        abort(400, description="Cannot change firebase_uid")
    
    current_data.update(data)
    
    try:
        # Validate the updated data
        updated_customer = CustomerModel(**current_data)
        
        # Update the document with validated data
        doc_ref.update(updated_customer.to_dict())
        
        # Return updated customer with ID
        response_data = updated_customer.to_dict()
        response_data['id'] = doc.id
        return jsonify(response_data), 200
        
    except ValidationError as e:
        return jsonify({"error": str(e)}), 400

# DELETE a customer by document ID
@app.route('/customers/<customer_id>', methods=['DELETE'])
def delete_customer(customer_id):
    doc_ref = db.collection('customers').document(customer_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Customer not found")
    
    doc_ref.delete()
    return jsonify({"message": f"Customer {customer_id} deleted"}), 200


# Add credits to a customer account
@app.route('/customers/<customer_id>/add-credits', methods=['POST', 'OPTIONS'])
def add_customer_credits(customer_id):
    if request.method == 'OPTIONS':
        return make_response('', 200)

    data = request.json
    if not data or 'amount' not in data:
        abort(400, description="Missing amount in request body")
    
    # Validate amount is a positive number
    try:
        amount = float(data['amount'])
        if amount <= 0:
            abort(400, description="Amount must be greater than zero")
    except ValueError:
        abort(400, description="Amount must be a valid number")
    
    doc_ref = db.collection('customers').document(customer_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Customer not found")
    
    # Get current data
    current_data = doc.to_dict()
    current_credits = current_data.get('customer_credits', 0)
    
    # Update credits
    new_credits = current_credits + amount
    
    # Update the document with new credits
    doc_ref.update({'customer_credits': new_credits})
    
    # Return updated credits
    return jsonify({
        'previous_credits': current_credits,
        'added_amount': amount,
        'new_credits': new_credits
    }), 200

@app.route('/customers/<customer_id>/deduct-credits', methods=['POST'])
def deduct_customer_credits(customer_id):
    data = request.json
    if not data or 'amount' not in data:
        abort(400, description="Missing amount in request body")
    
    # Validate amount is a positive number
    try:
        amount = float(data['amount'])
        if amount <= 0:
            abort(400, description="Amount must be greater than zero")
    except ValueError:
        abort(400, description="Amount must be a valid number")
    
    doc_ref = db.collection('customers').document(customer_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Customer not found")
    
    # Get current data
    current_data = doc.to_dict()
    current_credits = current_data.get('customer_credits', 0)
    
    # Check if customer has enough credits
    if current_credits < amount:
        abort(400, description="Insufficient credits")
    
    # Update credits
    new_credits = current_credits - amount
    
    # Update the document with new credits
    doc_ref.update({'customer_credits': new_credits})
    
    # Return updated credits
    return jsonify({
        'previous_credits': current_credits,
        'deducted_amount': amount,
        'new_credits': new_credits
    }), 200


if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000, threaded=True)
</file>

<file path="atomic/Dockerfile.customer">
FROM python:3.12-slim

# Set working directory
WORKDIR /app

# Copy requirements first to leverage Docker cache
COPY atomic_requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r atomic_requirements.txt

# Copy application code
COPY ./atomic/customer.py /app/atomic/
COPY ./atomic/__init__.py /app/atomic/
COPY ./models/ /app/models/
COPY .env.docker /app/.env
COPY firebase-adminsdk.json /app/firebase-adminsdk.json

# Set environment variables
ENV PYTHONPATH=/app
ENV FLASK_APP=/app/atomic/customer.py
ENV FLASK_RUN_HOST=0.0.0.0

# Expose the port that the service runs on
EXPOSE 5000

# Run the service
CMD ["python", "/app/atomic/customer.py"]
</file>

<file path="atomic/Dockerfile.order">
FROM python:3.12-slim

# Set working directory
WORKDIR /app

# Copy requirements first to leverage Docker cache
COPY atomic_requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r atomic_requirements.txt

# Copy the service code and models
COPY ./atomic/order.py /app/atomic/
COPY ./atomic/__init__.py /app/atomic/
COPY ./models/ /app/models/
COPY .env.docker /app/.env
COPY firebase-adminsdk.json /app/firebase-adminsdk.json

# Set environment variables
ENV PYTHONPATH=/app
ENV FLASK_APP=/app/atomic/order.py
ENV FLASK_RUN_HOST=0.0.0.0

# Expose the port that the service runs on
EXPOSE 5003

# Run the service
CMD ["python", "/app/atomic/order.py"]
</file>

<file path="atomic/Dockerfile.payment">
# Use a Python base image
FROM python:3.12-slim

# Set the working directory inside the container
WORKDIR /app

# Copy the requirements file for the payment service
COPY atomic_requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r atomic_requirements.txt

# Copy application code
COPY ./atomic/payment.py /app/atomic/ 
COPY ./atomic/__init__.py /app/atomic/
COPY ./models/ /app/models/
COPY .env.docker /app/.env
COPY firebase-adminsdk.json /app/firebase-adminsdk.json

# Set environment variables
ENV PYTHONPATH=/app
ENV FLASK_APP=/app/atomic/payment.py
ENV FLASK_RUN_HOST=0.0.0.0

# Expose the port that the service runs on (5007 for payment service)
EXPOSE 5004

# Run the service
CMD ["python", "/app/atomic/payment.py"]
</file>

<file path="atomic/Dockerfile.picker">
FROM python:3.12-slim

# Set working directory
WORKDIR /app

# Copy requirements first to leverage Docker cache
COPY atomic_requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r atomic_requirements.txt

# Copy the service code and models
COPY ./atomic/picker.py /app/atomic/
COPY ./atomic/__init__.py /app/atomic/
COPY ./models/ /app/models/
COPY .env.docker /app/.env
COPY firebase-adminsdk.json /app/firebase-adminsdk.json

# Set environment variables
ENV PYTHONPATH=/app
ENV FLASK_APP=/app/atomic/picker.py
ENV FLASK_RUN_HOST=0.0.0.0

# Expose the port that the service runs on
EXPOSE 5001

# Run the service
CMD ["python", "/app/atomic/picker.py"]
</file>

<file path="atomic/Dockerfile.stall">
FROM python:3.12-slim

# Set working directory
WORKDIR /app

# Copy requirements first to leverage Docker cache
COPY atomic_requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r atomic_requirements.txt

# Copy the service code and models
COPY ./atomic/stall.py /app/atomic/
COPY ./atomic/__init__.py /app/atomic/
COPY ./models/ /app/models/
COPY .env.docker /app/.env
COPY firebase-adminsdk.json /app/firebase-adminsdk.json

# Set environment variables
ENV PYTHONPATH=/app
ENV FLASK_APP=/app/atomic/stall.py
ENV FLASK_RUN_HOST=0.0.0.0

# Expose the port that the service runs on
EXPOSE 5002

# Run the service
CMD ["python", "/app/atomic/stall.py"]
</file>

<file path="atomic/order.py">
import os
import sys
from datetime import datetime
from flask import Flask, request, jsonify, abort
from flask_cors import CORS
from dotenv import load_dotenv
import firebase_admin
from firebase_admin import credentials, firestore
from pydantic import ValidationError

# Add parent directory to path to resolve module imports
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Import the Pydantic model
from models.order_model import OrderModel, OrderItemModel

load_dotenv()  # Loads the .env file

# Initialize Firebase (if not already initialized)
if not firebase_admin._apps:
    cred_path = os.getenv("FIREBASE_SERVICE_ACCOUNT_KEY_PATH")
    cred = credentials.Certificate(cred_path)
    firebase_admin.initialize_app(cred)

# Set Firestore DB client.
db = firestore.client()

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# TEST
@app.route('/test', methods=['GET'])
def test():
    return "Order MS is running"

# GET all orders (including their order items)
@app.route('/orders', methods=['GET'])
def get_orders():
    orders_ref = db.collection('orders')
    docs = orders_ref.stream()
    orders = []
    for doc in docs:
        order = doc.to_dict()
        order['id'] = doc.id
        # Get order items from subcollection "order_items"
        items = []
        for item_doc in doc.reference.collection('order_items').stream():
            item = item_doc.to_dict()
            item['id'] = item_doc.id
            items.append(item)
        order['order_items'] = items
        orders.append(order)
    return jsonify(orders), 200

# GET a specific order by order_id.
@app.route('/orders/<order_id>', methods=['GET'])
def get_order(order_id):
    doc_ref = db.collection('orders').document(order_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Order not found")
    order = doc.to_dict()
    order['id'] = doc.id
    items = []
    for item_doc in doc_ref.collection('order_items').stream():
        item = item_doc.to_dict()
        item['id'] = item_doc.id
        items.append(item)
    order['order_items'] = items
    return jsonify(order), 200

# POST create a new order (with multiple order items) using Pydantic validation.
@app.route('/orders', methods=['POST'])
def create_order():
    data = request.get_json()
    if not data:
        abort(400, description="Missing JSON body")
    
    # Validate incoming data with the OrderModel
    try:
        order_model = OrderModel(**data)
        
        # Build order document data for Firestore
        order_data = order_model.to_dict()
        
        # Create order document
        doc_ref = db.collection('orders').document()
        doc_ref.set(order_data)
        
        # Process and add each order item to the "order_items" subcollection
        for item in order_model.order_items:
            doc_ref.collection('order_items').add(item.to_dict())
        
        # Return the new order with its ID and items
        new_order = order_data
        new_order['id'] = doc_ref.id
        
        # Include serialized order items in the response
        new_order['order_items'] = [
            {**item.to_dict(), 'id': i} 
            for i, item in enumerate(order_model.order_items)
        ]
        
        return jsonify(new_order), 201
        
    except ValidationError as e:
        return jsonify({"error": str(e)}), 400


# PUT update an existing order.
@app.route('/orders/<order_id>', methods=['PUT'])
def update_order(order_id):
    data = request.get_json()
    if not data:
        abort(400, description="Missing JSON body")
    
    order_doc_ref = db.collection('orders').document(order_id)
    order_doc = order_doc_ref.get()
    if not order_doc.exists:
        abort(404, description="Order not found")
    
    # Get current data and merge with update
    current_data = order_doc.to_dict()
    
    # Get current order items
    current_items = []
    for item_doc in order_doc_ref.collection('order_items').stream():
        item = item_doc.to_dict()
        item['id'] = item_doc.id
        current_items.append(item)
    
    # Extract order items from the update if present
    update_items = data.pop('order_items', None)
    
    # Update the main order data
    if data:
        current_data.update(data)
    
    try:
        # Validate the order data (without items for now)
        temp_items = current_items if update_items is None else update_items
        order_model = OrderModel.from_dict(current_data, temp_items)
        
        # Update the order document with validated data
        order_doc_ref.update(order_model.to_dict())
        
        # If new order items were provided, handle them
        if update_items is not None:
            # Delete existing order items
            for item_doc in order_doc_ref.collection('order_items').stream():
                item_doc.reference.delete()
            
            # Add new order items
            for item_data in update_items:
                # Remove any id field as it's not part of the model
                if 'id' in item_data:
                    item_data.pop('id')
                
                # Validate item data
                item_model = OrderItemModel(**item_data)
                
                # Add to Firestore
                order_doc_ref.collection('order_items').add(item_model.to_dict())
        
        # Return the updated order with its items
        updated_order = order_model.to_dict()
        updated_order['id'] = order_id
        
        # Get the updated items from Firestore
        items = []
        for item_doc in order_doc_ref.collection('order_items').stream():
            item = item_doc.to_dict()
            item['id'] = item_doc.id
            items.append(item)
        updated_order['order_items'] = items
        
        return jsonify(updated_order), 200
        
    except ValidationError as e:
        return jsonify({"error": str(e)}), 400

# PATCH to update order status
@app.route('/orders/<order_id>/status', methods=['PATCH'])
def update_order_status(order_id):
    data = request.get_json()
    if not data or 'order_status' not in data:
        abort(400, description="Request must include 'order_status'")
    
    order_doc_ref = db.collection('orders').document(order_id)
    order_doc = order_doc_ref.get()
    if not order_doc.exists:
        abort(404, description="Order not found")
    
    # Get current data and update status
    current_data = order_doc.to_dict()
    current_data['order_status'] = data['order_status']
    
    # If status is completed, add completion timestamp
    if data['order_status'] == 'completed':
        current_data['order_completed'] = datetime.now().isoformat()
    
    try:
        # Validate with the current items
        items = []
        for item_doc in order_doc_ref.collection('order_items').stream():
            item = item_doc.to_dict()
            items.append(item)
        
        # Create model instance to validate
        order_model = OrderModel.from_dict(current_data, items)
        
        # Update only the status field
        update_data = {'order_status': data['order_status']}
        if data['order_status'] == 'completed':
            update_data['order_completed'] = current_data['order_completed']
        
        order_doc_ref.update(update_data)
        
        # Return success response
        return jsonify({
            'id': order_id,
            'order_status': data['order_status'],
            'message': f"Order status updated to {data['order_status']}"
        }), 200
        
    except ValidationError as e:
        return jsonify({"error": str(e)}), 400

# DELETE an order by order_id.
@app.route('/orders/<order_id>', methods=['DELETE'])
def delete_order(order_id):
    order_doc_ref = db.collection('orders').document(order_id)
    order_doc = order_doc_ref.get()
    if not order_doc.exists:
        abort(404, description="Order not found")
    
    # Delete all order items in the subcollection first
    for item_doc in order_doc_ref.collection('order_items').stream():
        item_doc.reference.delete()
    
    # Then delete the main order document
    order_doc_ref.delete()
    
    return jsonify({
        "message": f"Order {order_id} and all its items deleted successfully"
    }), 200

# Optional: Add an endpoint to get all orders for a specific customer
@app.route('/customers/<customer_id>/orders', methods=['GET'])
def get_customer_orders(customer_id):
    orders_ref = db.collection('orders').where('customer_id', '==', customer_id)
    docs = orders_ref.stream()
    
    orders = []
    for doc in docs:
        order = doc.to_dict()
        order['id'] = doc.id
        
        # Get order items
        items = []
        for item_doc in doc.reference.collection('order_items').stream():
            item = item_doc.to_dict()
            item['id'] = item_doc.id
            items.append(item)
        
        order['order_items'] = items
        orders.append(order)
    
    return jsonify(orders), 200

# Optional: Add an endpoint to get all orders assigned to a specific picker
@app.route('/pickers/<picker_id>/orders', methods=['GET'])
def get_picker_orders(picker_id):
    orders_ref = db.collection('orders').where('picker_id', '==', picker_id)
    docs = orders_ref.stream()
    
    orders = []
    for doc in docs:
        order = doc.to_dict()
        order['id'] = doc.id
        
        # Get order items
        items = []
        for item_doc in doc.reference.collection('order_items').stream():
            item = item_doc.to_dict()
            item['id'] = item_doc.id
            items.append(item)
        
        order['order_items'] = items
        orders.append(order)
    
    return jsonify(orders), 200


#updates location for the order 
@app.route("/orders/<order_id>/location", methods=['PATCH'])
def update_location(order_id):
    try:
        data = request.get_json()
        if not data:
            return jsonify({"code": 400, "message": "Missing JSON body"}), 400
            
        new_location = data.get("location")
        if not new_location:
            return jsonify({"code": 400, "message": "New location is required"}), 400
            
        # Validate location structure
        required_fields = ["address", "coordinates", "postal"]
        if not all(field in new_location for field in required_fields):
            return jsonify({"code": 400, "message": "Location must include address, coordinates, and postal code"}), 400
            
        coordinates = new_location.get("coordinates", {})
        if "lat" not in coordinates or "lng" not in coordinates:
            return jsonify({"code": 400, "message": "Coordinates must include both lat and lng"}), 400
            
        # Get order document
        order_ref = db.collection("orders").document(order_id)
        order = order_ref.get()
        if not order.exists:
            return jsonify({"code": 404, "message": "Order not found"}), 404
            
        # Get current order data
        order_data = order.to_dict()
        
        # Check if order status allows location update
        allowed_statuses = ["pending", "assigned", "preparing"]
        if order_data.get('order_status') not in allowed_statuses:
            return jsonify({"code": 400, 
                           "message": "Cannot update location for orders that are already delivering, completed, or cancelled"}), 400
        
        # Update both location and order_location fields
        update_fields = {"location": new_location}
        
        # Always update order_location, even if it doesn't exist yet
        update_fields["order_location"] = f"{new_location['address']}, {new_location['postal']}"
            
        # Update the document
        order_ref.update(update_fields)
        
        # Return success response with updated location
        return jsonify({
            "code": 200, 
            "message": f"Order {order_id} location updated successfully",
            "location": new_location,
            "order_location": update_fields["order_location"]
        }), 200
            
    except Exception as e:
        print(f"Error updating location: {str(e)}")
        return jsonify({"code": 500, "message": f"Server error: {str(e)}"}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5003, threaded=True)
</file>

<file path="atomic/payment.py">
import requests
import json
import firebase_admin
from firebase_admin import credentials, firestore
from flask import Flask, request, jsonify
import os
from datetime import datetime

# Initialize Flask app
app = Flask(__name__)

from flask_cors import CORS
CORS(app)

# Initialize firebase
if not firebase_admin._apps:
    cred_path = os.getenv("FIREBASE_SERVICE_ACCOUNT_KEY_PATH")
    cred = credentials.Certificate(cred_path)
    firebase_admin.initialize_app(cred)

# Connect to Firestore
db = firestore.client()

ORDER_SERVICE_URL = "http://localhost:5003"  # Order service URL

@app.route("/")
def home():
    return "Payment Microservice (Using Firebase Firestore)"

# Get all payments
@app.route("/payments", methods=['GET'])
def get_all_payments():
    payments_ref = db.collection('payments')
    docs = payments_ref.stream()
    payments = [doc.to_dict() for doc in docs]

    if payments:
        return jsonify({"code": 200, "data": payments}), 200
    else:
        return jsonify({"code": 404, "message": "No payments found."}), 404
    
# Update payment status (includes 'refunded')
@app.route("/payment/<payment_id>/status", methods=['PUT'])
def update_payment_status(payment_id):
    data = request.get_json()
    new_status = data.get('payment_status')

    if not new_status:
        return jsonify({"code": 400, "message": "Payment status is required."}), 400

    payment_ref = db.collection('payments').document(payment_id)
    payment_ref.update({"payment_status": new_status})

    return jsonify({"code": 200, "message": f"Payment {payment_id} status updated to {new_status}."}), 200

# Get specific payment with payment_status
@app.route("/payment/<payment_id>", methods=['GET'])
def get_payment(payment_id):
    payment_ref = db.collection('payments').document(payment_id)
    payment = payment_ref.get()
    
    if payment.exists:
        payment_data = payment.to_dict()
        payment_status = payment_data.get("payment_status", "Unknown")
        return jsonify({"code": 200, "payment_status": payment_status}), 200
    else:
        return jsonify({"code": 404, "message": f"Payment {payment_id} not found."}), 404

# Get transaction details as JSON string
@app.route("/payment/<payment_id>/transaction", methods=['GET'])
def get_payment_details(payment_id):
    payment_ref = db.collection('payments').document(payment_id)
    payment = payment_ref.get()
    
    if payment.exists:
        payment_data = payment.to_dict()
        # Extracting the relevant payment fields
        required_fields = ["log_id", "order_id", "customer_id", "event_type", "event_details", "payment_amount", "payment_status", "timestamp"]
        payment_details = {field: payment_data.get(field, "Unknown") for field in required_fields}
        return jsonify({"code": 200, "payment_details": payment_details}), 200
    else:
        return jsonify({"code": 404, "message": f"Payment {payment_id} not found."}), 404

# Create a new payment transaction
@app.route('/payment', methods=['POST'])
def create_payment_transaction():
    data = request.get_json()
    
    # Define common required fields for both scenarios.
    common_required = [
        "log_id", 
        "customer_id", 
        "event_type", 
        "event_details", 
        "payment_amount", 
        "payment_status", 
        "timestamp"
    ]
    
    # Check for missing common fields.
    missing_common = [field for field in common_required if field not in data]
    if missing_common:
        return jsonify({"error": f"Missing required field(s): {', '.join(missing_common)}"}), 400

    event_type = data.get("event_type")
    
    # For order payments, require "order_id".
    if event_type == "Payment":
        if "order_id" not in data:
            return jsonify({"error": "Missing required field: order_id for Payment events"}), 400
    else:
        # For Credit Top-Up, remove the order_id if it exists, since it's not applicable.
        data.pop("order_id", None)
    
    # Validate payment_amount is a positive number.
    try:
        amount = float(data["payment_amount"])
        if amount <= 0:
            return jsonify({"error": "payment_amount must be greater than zero"}), 400
    except (ValueError, TypeError):
        return jsonify({"error": "payment_amount must be a valid number"}), 400

    # Build the payment transaction record.
    payment_data = {
        "log_id": data["log_id"],
        "customer_id": data["customer_id"],
        "event_type": event_type,
        "event_details": data["event_details"],
        "payment_amount": amount,
        "payment_status": data["payment_status"],
        "timestamp": data["timestamp"],
    }

    # Include order_id only if event_type is "Payment"
    if event_type == "Payment":
        payment_data["order_id"] = data["order_id"]

    # Create a new document in the 'payments' collection.
    payment_ref = db.collection('payments').document()
    # Add the Firestore document ID to the payment data as payment_id.
    payment_data["payment_id"] = payment_ref.id

    payment_ref.set(payment_data)

    return jsonify({
        "message": "Payment transaction created successfully.",
        "transaction_id": payment_ref.id,
        "payment_data": payment_data
    }), 201

# Delete a payment
@app.route("/payments/<paymentID>", methods=['DELETE'])
def delete_payment(paymentID):
    payment_ref = db.collection('payments').document(paymentID)
    payment = payment_ref.get()

    if not payment.exists:
        return jsonify({"code": 404, "message": f"Payment {paymentID} not found."}), 404

    payment_ref.delete()
    return jsonify({"code": 200, "message": f"Payment {paymentID} has been deleted."}), 200

# Get payments by customer ID
@app.route("/payments/customer/<customer_id>", methods=['GET'])
def get_payments_by_customer_id(customer_id):
    try:
        # Query payments by customer_id
        payments_ref = db.collection("payments")
        query = payments_ref.where("customer_id", "==", customer_id)
        payments = query.stream()
        
        # Collect payments from query and format them into a list
        payment_list = []
        for payment in payments:
            payment_list.append(payment.to_dict())

        return jsonify(payment_list), 200  # Return only the list of payments
    except Exception as e:
        print(f"Error fetching payments: {e}")
        return jsonify({"error": "Could not fetch payments"}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5004, threaded=True)
</file>

<file path="atomic/picker.py">
from flask import Flask, request, jsonify, abort
from flask_cors import CORS
import os
import sys
from dotenv import load_dotenv
import firebase_admin
from firebase_admin import credentials, firestore
from pydantic import ValidationError
from models.picker_model import PickerModel

# Add parent directory to path to resolve module imports
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

load_dotenv()  # Loads the .env file

# Initialize Firebase (if not already initialized)
if not firebase_admin._apps:
    cred_path = os.getenv("FIREBASE_SERVICE_ACCOUNT_KEY_PATH")
    cred = credentials.Certificate(cred_path)
    firebase_admin.initialize_app(cred)

# Set Firestore DB client.
db = firestore.client()

app = Flask(__name__)
CORS(app)

# TEST
@app.route('/test', methods=['GET'])
def test():
    return "Picker MS is running"

# GET all pickers.
@app.route('/pickers', methods=['GET'])
def get_pickers():
    pickers_ref = db.collection('pickers')
    docs = pickers_ref.stream()
    pickers = []
    for doc in docs:
        picker = doc.to_dict()
        picker['id'] = doc.id
        pickers.append(picker)
    return jsonify(pickers), 200

# GET all Available pickers.
@app.route('/pickers/available', methods=['GET'])
def get_available_pickers():
    pickers_ref = db.collection('pickers').where("is_available", "==", True)
    docs = pickers_ref.stream()
    pickers = []
    for doc in docs:
        picker = doc.to_dict()
        picker['id'] = doc.id
        pickers.append(picker)
    return jsonify(pickers), 200

# GET a specific picker by document ID (which is now the Firebase UID).
@app.route('/pickers/<picker_id>', methods=['GET'])
def get_picker(picker_id):
    doc_ref = db.collection('pickers').document(picker_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Picker not found")
    picker = doc.to_dict()
    picker['id'] = doc.id
    return jsonify(picker), 200

# POST create a new picker.
@app.route('/pickers', methods=['POST'])
def create_picker():
    data = request.get_json()
    if not data:
        abort(400, description="Missing request body")
    
    # Check if firebase_uid is provided
    if 'firebase_uid' not in data:
        abort(400, description="firebase_uid is required")
    
    firebase_uid = data['firebase_uid']
    
    # Check if picker already exists with this firebase_uid
    doc_ref = db.collection('pickers').document(firebase_uid)
    if doc_ref.get().exists:
        abort(409, description="Picker with this Firebase UID already exists")
    
    try:
        # Validate picker data using Pydantic model
        picker_model = PickerModel(**data)
        
        # Use the firebase_uid as the document ID
        doc_ref.set(picker_model.to_dict())
        
        # Return the new picker with its ID
        new_picker = picker_model.to_dict()
        new_picker['id'] = firebase_uid
        return jsonify(new_picker), 201
        
    except ValidationError as e:
        return jsonify({"error": str(e)}), 400

# PUT update an existing picker.
@app.route('/pickers/<picker_id>', methods=['PUT'])
def update_picker(picker_id):
    doc_ref = db.collection('pickers').document(picker_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Picker not found")
    
    data = request.get_json()
    if not data:
        abort(400, description="Missing request body")
    
    # Don't allow changing firebase_uid
    if 'firebase_uid' in data and data['firebase_uid'] != picker_id:
        abort(400, description="Cannot change firebase_uid")
    
    try:
        # Get current data and update with new data
        current_data = doc.to_dict()
        current_data.update(data)
        
        # Validate the updated data
        updated_picker = PickerModel(**current_data)
        
        # Update the document with validated data
        doc_ref.update(updated_picker.to_dict())
        
        # Return updated picker with ID
        response_data = updated_picker.to_dict()
        response_data['id'] = doc.id
        return jsonify(response_data), 200
        
    except ValidationError as e:
        return jsonify({"error": str(e)}), 400

# PATCH to update picker availability
@app.route('/pickers/<picker_id>/availability', methods=['PATCH'])
def update_availability(picker_id):
    doc_ref = db.collection('pickers').document(picker_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Picker not found")
    
    data = request.get_json()
    if not isinstance(data, dict) or 'is_available' not in data:
        abort(400, description="Request must include 'is_available' field")
    
    # Get the current picker data
    current_data = doc.to_dict()
    current_data.update({'is_available': data['is_available']})
    
    try:
        # Validate the updated data
        updated_picker = PickerModel(**current_data)
        
        # Update just the availability field
        doc_ref.update({'is_available': data['is_available']})
        
        # Return updated picker with ID
        response_data = updated_picker.to_dict()
        response_data['id'] = doc.id
        return jsonify(response_data), 200
        
    except ValidationError as e:
        return jsonify({"error": str(e)}), 400

# DELETE a picker by document ID.
@app.route('/pickers/<picker_id>', methods=['DELETE'])
def delete_picker(picker_id):
    doc_ref = db.collection('pickers').document(picker_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Picker not found")
    doc_ref.delete()
    return jsonify({"message": f"Picker {picker_id} deleted"}), 200

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5001, threaded=True)
</file>

<file path="atomic/stall.py">
from flask import Flask, request, jsonify, abort
from flask_cors import CORS
import os
from dotenv import load_dotenv
import firebase_admin
from firebase_admin import credentials, firestore
from pydantic import ValidationError
from models.stall_model import StallModel, MenuItemModel

load_dotenv()  # Loads the .env file

# Initialize Firebase (if not already initialized)
if not firebase_admin._apps:
    cred_path = os.getenv("FIREBASE_SERVICE_ACCOUNT_KEY_PATH")
    cred = credentials.Certificate(cred_path)
    firebase_admin.initialize_app(cred)

# Set the Firestore DB client.
db = firestore.client()

app = Flask(__name__)
CORS(app)

# TEST
@app.route('/test', methods=['GET'])
def test():
    return "Stall MS is running"

# GET all food stalls with their menus.
@app.route("/stalls", methods=["GET"])
def get_stalls():
    stalls_ref = db.collection("stalls")
    docs = stalls_ref.stream()
    stalls = []
    for doc in docs:
        stall_data = doc.to_dict()
        stall_data["id"] = doc.id
        # Retrieve menu items as documents in the subcollection "menu".
        menu_docs = doc.reference.collection("menu").stream()
        menu_items = []
        for menu_doc in menu_docs:
            menu_item = menu_doc.to_dict()
            menu_item["id"] = menu_doc.id
            menu_items.append(menu_item)
        stall_data["menu"] = menu_items
        stalls.append(stall_data)
    return jsonify(stalls), 200


# GET a specific food stall by stall_id.
@app.route("/stalls/<stall_id>", methods=["GET"])
def get_stall(stall_id):
    doc_ref = db.collection("stalls").document(stall_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Food stall not found")
    stall_data = doc.to_dict()
    stall_data["id"] = doc.id
    # Get the stall's menu (from the "menu" subcollection)
    menu_docs = doc_ref.collection("menu").stream()
    menu_items = []
    for menu_doc in menu_docs:
        menu_item = menu_doc.to_dict()
        menu_item["id"] = menu_doc.id
        menu_items.append(menu_item)
    stall_data["menu"] = menu_items
    return jsonify(stall_data), 200


# POST to create a new food stall.
@app.route("/stalls", methods=["POST"])
def create_stall():
    data = request.get_json()
    if not data:
        abort(400, description="Missing request body")

    try:
        # Validate stall data using Pydantic model (excluding menu items)
        menu_items = data.pop("menu", [])
        stall_model = StallModel(**data)

        # Add the new stall document to Firestore
        doc_ref = db.collection("stalls").document()
        doc_ref.set(stall_model.to_dict())

        # Return the new stall with its ID
        new_stall = stall_model.to_dict()
        new_stall["id"] = doc_ref.id
        new_stall["menu"] = []

        # Add menu items if provided
        if menu_items:
            return add_menu_items(doc_ref.id, menu_items)

        return jsonify(new_stall), 201

    except ValidationError as e:
        return jsonify({"error": str(e)}), 400


# PUT to update an existing food stall.
@app.route("/stalls/<stall_id>", methods=["PUT"])
def update_stall(stall_id):
    data = request.get_json()
    if not data:
        abort(400, description="Missing request body")

    doc_ref = db.collection("stalls").document(stall_id)
    doc = doc_ref.get()

    if not doc.exists:
        abort(404, description="Food stall not found")

    try:
        # If menu is included, handle it separately
        menu_items = data.pop("menu", None)

        # Get current data and update with new data
        current_data = doc.to_dict()
        current_data.update(data)

        # Validate the updated data
        stall_model = StallModel.from_dict(current_data)

        # Update the document with validated data
        doc_ref.update(stall_model.to_dict())

        # Re-read the updated document
        updated_doc = doc_ref.get()
        stall_data = updated_doc.to_dict()
        stall_data["id"] = updated_doc.id

        # Also fetch updated menu items.
        menu_docs = doc_ref.collection("menu").stream()
        menu_list = []
        for menu_doc in menu_docs:
            item = menu_doc.to_dict()
            item["id"] = menu_doc.id
            menu_list.append(item)
        stall_data["menu"] = menu_list

        # If menu items were provided, update them
        if menu_items is not None:
            # Delete existing menu items
            for menu_doc in doc_ref.collection("menu").stream():
                menu_doc.reference.delete()

            # Add new menu items
            if menu_items:
                add_menu_items(stall_id, menu_items)
                stall_data["menu"] = menu_items

        return jsonify(stall_data), 200

    except ValidationError as e:
        return jsonify({"error": str(e)}), 400


# DELETE a food stall (and its associated menu items).
@app.route("/stalls/<stall_id>", methods=["DELETE"])
def delete_stall(stall_id):
    doc_ref = db.collection("stalls").document(stall_id)
    doc = doc_ref.get()
    if not doc.exists:
        abort(404, description="Food stall not found")
    # Delete all menu items in the "menu" subcollection.
    menu_collection = doc_ref.collection("menu")
    for menu_doc in menu_collection.stream():
        menu_doc.reference.delete()
    # Delete the stall document.
    doc_ref.delete()
    return jsonify({"message": f"Food stall {stall_id} deleted"}), 200


# GET all food items for a specific stall (its menu).
@app.route("/stalls/<stall_id>/menu", methods=["GET"])
def get_menu(stall_id):
    doc_ref = db.collection("stalls").document(stall_id)
    if not doc_ref.get().exists:
        abort(404, description="Food stall not found")
    menu_docs = doc_ref.collection("menu").stream()
    menu_items = []
    for menu_doc in menu_docs:
        item = menu_doc.to_dict()
        item["id"] = menu_doc.id
        menu_items.append(item)
    return jsonify(menu_items), 200


# Helper function to add menu items
def add_menu_items(stall_id, items):
    doc_ref = db.collection("stalls").document(stall_id)
    if not doc_ref.get().exists:
        abort(404, description="Food stall not found")

    new_items = []
    for item in items:
        try:
            # Validate menu item using Pydantic model
            menu_item = MenuItemModel(**item)
            item_dict = menu_item.to_dict()

            # Add the food item to the "menu" subcollection
            menu_doc_ref = doc_ref.collection("menu").document()
            menu_doc_ref.set(item_dict)

            # Add ID to the item
            item_dict["id"] = menu_doc_ref.id
            new_items.append(item_dict)

        except ValidationError as e:
            return jsonify({"error": f"Invalid menu item: {str(e)}"}), 400

    # Get updated stall data
    stall_doc = doc_ref.get()
    stall_data = stall_doc.to_dict()
    stall_data["id"] = stall_doc.id
    stall_data["menu"] = new_items

    return jsonify(stall_data), 201


# POST to add multiple food items to a stall's menu.
@app.route("/stalls/<stall_id>/menu", methods=["POST"])
def add_multiple_menu_items(stall_id):
    items = request.get_json()
    if not items or not isinstance(items, list):
        abort(400, description="Expected a JSON list of food items")

    return add_menu_items(stall_id, items)


# PUT to update an existing food item for a stall.
@app.route("/stalls/<stall_id>/menu/<food_id>", methods=["PUT"])
def update_menu_item(stall_id, food_id):
    doc_ref = db.collection("stalls").document(stall_id)
    menu_doc_ref = doc_ref.collection("menu").document(food_id)

    if not menu_doc_ref.get().exists:
        abort(404, description="Menu item not found for this stall")

    data = request.get_json()
    if not data:
        abort(400, description="Missing request body")

    try:
        # Get current data and update with new data
        current_data = menu_doc_ref.get().to_dict()
        current_data.update(data)

        # Validate the updated data
        menu_item = MenuItemModel(**current_data)

        # Update the document with validated data
        menu_doc_ref.update(menu_item.to_dict())

        # Return updated menu item with ID
        updated_data = menu_item.to_dict()
        updated_data["id"] = food_id
        return jsonify(updated_data), 200

    except ValidationError as e:
        return jsonify({"error": str(e)}), 400


# DELETE a food item from a stall's menu.
@app.route("/stalls/<stall_id>/menu/<food_id>", methods=["DELETE"])
def delete_menu_item(stall_id, food_id):
    doc_ref = db.collection("stalls").document(stall_id)
    menu_doc_ref = doc_ref.collection("menu").document(food_id)
    if not menu_doc_ref.get().exists:
        abort(404, description="Menu item not found for this stall")
    menu_doc_ref.delete()
    return (
        jsonify({"message": f"Menu item {food_id} deleted from stall {stall_id}"}),
        200,
    )


# Test function to add bulk data
@app.route("/test/add-bulk-data", methods=["POST"])
def add_bulk_test_data():
    # Sample data updated to match the current model
    test_data = [
        {
            "stall_name": "Prata Shop",
            "stall_image": "/images/prata-shop.jpg",
            "stall_description": "Authentic prata shop with the best recipes",
            "rating": 4.5,
            "review_count": 120,
            "cuisines": ["Indian", "Halal"],
            "preparation_time_mins": 15,
            "delivery_fee": 3.50,
            "stall_location": "40 Stamford Road #01-06 SMU Connexion Singapore 178908",
            "is_promoted": True,
            "menu": [
                {
                    "food_name": "Original Prata",
                    "food_price": 9.99,
                    "food_description": "Best Prata in the world",
                    "food_category": "Main",
                    "food_image": "/images/original-prata.jpg",
                },
                {
                    "food_name": "Cheese Prata",
                    "food_price": 10.50,
                    "food_description": "Prata filled with melted cheese",
                    "food_category": "Main",
                    "food_image": "/images/original-prata.jpg",
                },
                {
                    "food_name": "Egg Prata",
                    "food_price": 9.50,
                    "food_description": "Prata with a perfectly cooked egg inside",
                    "food_category": "Main",
                    "food_image": "/images/original-prata.jpg",
                },
                {
                    "food_name": "Chicken Prata",
                    "food_price": 11.00,
                    "food_description": "Prata stuffed with spicy chicken filling",
                    "food_category": "Main",
                    "food_image": "/images/original-prata.jpg",
                },
                {
                    "food_name": "Mutton Prata",
                    "food_price": 12.00,
                    "food_description": "Delicious prata with a hearty mutton filling",
                    "food_category": "Main",
                    "food_image": "/images/original-prata.jpg",
                },
            ],
        },
        {
            "stall_name": "Pasta Express",
            "stall_image": "/images/pasta-express.jpg",
            "stall_description": "Quick Italian pasta dishes",
            "rating": 4.2,
            "review_count": 85,
            "cuisines": ["Italian", "Western"],
            "preparation_time_mins": 10,
            "delivery_fee": 2.50,
            "stall_location": "40 Stamford Road #01-05 SMU Connexion Singapore 178908",
            "is_promoted": False,
            "menu": [
                {
                    "food_name": "Aglio Olio Pasta",
                    "food_price": 9.0,
                    "food_description": "Classic garlic and olive oil pasta",
                    "food_category": "Main",
                    "food_image": "/images/aglio-olio.jpg",
                },
                {
                    "food_name": "Bolognese Pasta",
                    "food_price": 7.0,
                    "food_description": "Hearty meat sauce pasta",
                    "food_category": "Main",
                    "food_image": "/images/aglio-olio.jpg",
                },
                {
                    "food_name": "Carbonara Pasta",
                    "food_price": 8.5,
                    "food_description": "Creamy pasta with bacon and egg",
                    "food_category": "Main",
                    "food_image": "/images/aglio-olio.jpg",
                },
                {
                    "food_name": "Pesto Pasta",
                    "food_price": 8.0,
                    "food_description": "Pasta tossed in a fresh basil pesto sauce",
                    "food_category": "Main",
                    "food_image": "/images/aglio-olio.jpg",
                },
                {
                    "food_name": "Seafood Pasta",
                    "food_price": 10.0,
                    "food_description": "Mixed seafood pasta in a light tomato sauce",
                    "food_category": "Main",
                    "food_image": "/images/aglio-olio.jpg",
                },
            ],
        },
        {
            "stall_name": "Kuro Kare",
            "stall_image": "/images/kuro-kare.jpg",
            "stall_description": "Japanese curry specialties",
            "rating": 4.7,
            "review_count": 150,
            "cuisines": ["Japanese", "Asian"],
            "preparation_time_mins": 12,
            "delivery_fee": 3.00,
            "stall_location": "40 Stamford Road #01-04 SMU Connexion Singapore 178908",
            "is_promoted": True,
            "menu": [
                {
                    "food_name": "Wasabi Mayo Chicken Katsu Curry Rice",
                    "food_price": 6.5,
                    "food_description": "Crispy chicken with wasabi mayo and curry",
                    "food_category": "Main",
                    "food_image": "/images/katsu.jpg",
                },
                {
                    "food_name": "Original Chicken Katsu Curry Rice",
                    "food_price": 6.0,
                    "food_description": "Classic chicken katsu with curry sauce",
                    "food_category": "Main",
                    "food_image": "/images/katsu.jpg",
                },
                {
                    "food_name": "Beef Curry Rice",
                    "food_price": 7.0,
                    "food_description": "Tender beef pieces in a rich curry sauce",
                    "food_category": "Main",
                    "food_image": "/images/katsu.jpg",
                },
                {
                    "food_name": "Vegetable Curry Rice",
                    "food_price": 5.5,
                    "food_description": "Mixed vegetables in a mild and aromatic curry",
                    "food_category": "Main",
                    "food_image": "/images/katsu.jpg",
                },
                {
                    "food_name": "Pork Curry Rice",
                    "food_price": 7.5,
                    "food_description": "Succulent pork simmered in a flavorful curry sauce",
                    "food_category": "Main",
                    "food_image": "/images/katsu.jpg",
                },
            ],
        },
        {
            "stall_name": "Michelin Nasi Lemak",
            "stall_image": "/images/nasi-lemak.jpg",
            "stall_description": "Delicious and authentic Nasi Lemak with a Michelin twist",
            "rating": 4.8,
            "review_count": 200,
            "cuisines": ["Malay", "Halal"],
            "preparation_time_mins": 20,
            "delivery_fee": 4.00,
            "stall_location": "10 Orchard Road #02-11 ION Orchard Singapore 238888",
            "is_promoted": True,
            "menu": [
                {
                    "food_name": "Classic Nasi Lemak",
                    "food_price": 8.50,
                    "food_description": "Traditional Nasi Lemak with sambal and anchovies",
                    "food_category": "Main",
                    "food_image": "/images/classic-nasi-lemak.jpg",
                },
                {
                    "food_name": "Spicy Sambal Nasi Lemak",
                    "food_price": 9.00,
                    "food_description": "Nasi Lemak with extra spicy sambal for a kick",
                    "food_category": "Main",
                    "food_image": "/images/classic-nasi-lemak.jpg",
                },
                {
                    "food_name": "Fried Chicken Nasi Lemak",
                    "food_price": 10.00,
                    "food_description": "Crispy fried chicken paired with creamy coconut rice",
                    "food_category": "Main",
                    "food_image": "/images/classic-nasi-lemak.jpg",
                },
                {
                    "food_name": "Vegetarian Nasi Lemak",
                    "food_price": 8.00,
                    "food_description": "A vegetarian twist on the classic, with tofu and tempeh",
                    "food_category": "Main",
                    "food_image": "/images/classic-nasi-lemak.jpg",
                },
                {
                    "food_name": "Egg Nasi Lemak",
                    "food_price": 8.75,
                    "food_description": "Perfectly cooked egg on a bed of coconut rice",
                    "food_category": "Main",
                    "food_image": "/images/classic-nasi-lemak.jpg",
                },
            ],
        },
        {
            "stall_name": "Subway Sandwich",
            "stall_image": "/images/subway-sandwich.jpg",
            "stall_description": "Freshly made sandwiches with a variety of fillings",
            "rating": 4.3,
            "review_count": 95,
            "cuisines": ["Western", "Fast Food"],
            "preparation_time_mins": 8,
            "delivery_fee": 2.75,
            "stall_location": "500 Changi Road #03-07 Changi City Point Singapore 486015",
            "is_promoted": False,
            "menu": [
                {
                    "food_name": "Turkey Sandwich",
                    "food_price": 7.50,
                    "food_description": "Sliced turkey with fresh veggies and sauce",
                    "food_category": "Main",
                    "food_image": "/images/sandwich.jpg",
                },
                {
                    "food_name": "Italian BMT",
                    "food_price": 8.00,
                    "food_description": "A classic sub with Italian cold cuts and cheese",
                    "food_category": "Main",
                    "food_image": "/images/sandwich.jpg",
                },
                {
                    "food_name": "Veggie Delite",
                    "food_price": 7.00,
                    "food_description": "A fresh mix of vegetables and light dressings",
                    "food_category": "Main",
                    "food_image": "/images/sandwich.jpg",
                },
                {
                    "food_name": "Chicken Teriyaki Sandwich",
                    "food_price": 8.25,
                    "food_description": "Grilled chicken with teriyaki sauce and lettuce",
                    "food_category": "Main",
                    "food_image": "/images/sandwich.jpg",
                },
                {
                    "food_name": "Tuna Sandwich",
                    "food_price": 7.75,
                    "food_description": "Classic tuna salad with crunchy vegetables",
                    "food_category": "Main",
                    "food_image": "/images/sandwich.jpg",
                },
            ],
        },
    ]

    # Results tracking
    results = {"success": [], "errors": []}

    # Process each stall
    for stall_data in test_data:
        try:
            # Extract menu items for separate validation
            menu_items = stall_data.pop("menu", [])

            # Validate stall data
            stall_model = StallModel(**stall_data)

            # Add stall to Firestore
            doc_ref = db.collection("stalls").document()
            doc_ref.set(stall_model.to_dict())
            stall_id = doc_ref.id

            # Process menu items
            menu_success = []
            for item in menu_items:
                try:
                    # Validate menu item
                    menu_item = MenuItemModel(**item)

                    # Add to Firestore
                    menu_doc_ref = doc_ref.collection("menu").document()
                    menu_doc_ref.set(menu_item.to_dict())

                    # Track success
                    item_with_id = menu_item.to_dict()
                    item_with_id["id"] = menu_doc_ref.id
                    menu_success.append(item_with_id)

                except Exception as e:
                    results["errors"].append(
                        f"Error adding menu item {item.get('food_name')} to stall {stall_data.get('stall_name')}: {str(e)}"
                    )

            # Record success
            stall_result = stall_model.to_dict()
            stall_result["id"] = stall_id
            stall_result["menu"] = menu_success
            results["success"].append(stall_result)

        except Exception as e:
            results["errors"].append(
                f"Error adding stall {stall_data.get('stall_name')}: {str(e)}"
            )

    return jsonify(results), 200


if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=5002, threaded=True)
</file>

<file path="composite/cancellation/cancellation.py">
import firebase_admin
from firebase_admin import credentials, firestore
from flask import Flask, request, jsonify

app = Flask(__name__)

# Initialize Firebase Admin SDK (assuming firebase-adminsdk.json is in the correct location)
try:
    cred = credentials.Certificate("../../firebase-adminsdk.json")
    firebase_admin.initialize_app(cred)
    db = firestore.client()
except Exception as e:
    print(f"Error initializing Firebase: {e}")


# Route to check service health
@app.route("/health", methods=['GET'])
def health_check():
    return jsonify({"status": "healthy", "service": "picker-status-updater"})


# Route to handle cancellations
@app.route("/cancellations", methods=['POST'])
def cancellations():
    try:
        data = request.get_json()
        
        # Extract necessary data from the request
        # order_id = data.get('order_id')
        # picker_id = data.get('picker_id')
        # set default order_id
        order_id = "6eOgo89MFZsfx7RCzXV5"

        # set defualt picker_id
        picker_id = "BDDla3MO5SBOdLG9Bju5"

        if not order_id or not picker_id:
            return jsonify({"error": "Order ID and Picker ID are required"}), 400
        
        # Update order status to 'Cancelled' by picker
        order_ref = db.collection('orders').document(order_id)
        order_ref.update({
            'status': 'Cancelled by Picker'
        })
        
        # Update picker status to 'Cancelled'
        picker_ref = db.collection('pickers').document(picker_id)
        picker_ref.update({
            'status': 'Available'
        })
        
        return jsonify({"message": "Order and Picker status updated successfully"}), 200

    except Exception as e:
        print(f"Error processing cancellation: {e}")
        return jsonify({"error": "Failed to process cancellation"}), 500


if __name__ == '__main__':
    app.run(port=5003, debug=True)
</file>

<file path="composite/refund/refund.py">
import firebase_admin
from firebase_admin import credentials, firestore
from flask import Flask, json, request, jsonify

# Initialize Flask app
app = Flask(__name__)

# Initialize Firebase Admin SDK (assuming firebase-adminsdk.json is in the correct location)
try:
    cred = credentials.Certificate("../../firebase-adminsdk.json")
    firebase_admin.initialize_app(cred)
    db = firestore.client()
except Exception as e:
    print(f"Error initializing Firebase: {e}")

# Connect to Firestore
db = firestore.client()

@app.route("/")
def home():
    return "Refund Microservice (Using Firebase Firestore)"

# POST /api/orders/{orderId}/refund
@app.route("/api/orders/<orderId>/refund", methods=['POST'])
async def create_refund(orderId):
    data = request.get_json()

    # Required fields
    required_fields = ["customerId", "paymentAmount", "refundReason", "photos"]

    # Check if all required fields are present in the request
    if not all(field in data for field in required_fields):
        return jsonify({"code": 400, "message": "Missing required fields."}), 400

    # Create a new refund document in Firestore
    refund_ref = db.collection('refunds').document()
    refund_id = refund_ref.id
    refund_data = {
        "orderId": orderId,
        "customerId": data["customerId"],
        "paymentAmount": data["paymentAmount"],
        "refundReason": data["refundReason"],
        "photos": json.dumps(data["photos"]),  # Store photos as a JSON string
        "status": "pending"  # Can add status to track refund state (optional)
    }

    # Set the refund data to Firestore
    refund_ref.set(refund_data)

    # Return the created refund details
    return jsonify({"code": 201, "data": refund_data}), 201

# PUT /api/payments/refund
@app.route("/api/payments/refund", methods=['PUT'])
async def update_refund():
    data = request.get_json()

    # Required fields
    required_fields = ["orderId", "customerId", "paymentAmount"]

    # Check if all required fields are present in the request
    if not all(field in data for field in required_fields):
        return jsonify({"code": 400, "message": "Missing required fields."}), 400

    # Find the refund document by orderId and customerId
    refund_ref = db.collection('refunds') \
                  .where('orderId', '==', data["orderId"]) \
                  .where('customerId', '==', data["customerId"]) \
                  .limit(1)  # Assuming there is only one refund per order and customer
    docs = refund_ref.stream()

    # Update refund details
    for refund in docs:
        refund_ref = db.collection('refunds').document(refund.id)
        refund_ref.update({"paymentAmount": data["paymentAmount"]})

        return jsonify({"code": 200, "message": "Refund updated successfully."}), 200

    return jsonify({"code": 404, "message": "Refund not found."}), 404


if __name__ == '__main__':
    app.run(port=5001, debug=True)
</file>

<file path="composite/assign_picker_v2.py">
from flask import Flask, request, jsonify, make_response
from flask_socketio import SocketIO, emit, join_room, leave_room
from flask_cors import CORS
import pika
import json
import threading
import requests
import time
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# This is for the CORS Error where they need pre-flight check to see if it exists or something
@app.route('/<path:path>', methods=['OPTIONS'])
@app.route('/', methods=['OPTIONS'])
def options_handler(path=None):
    return make_response('', 200)

# Configuration
RABBITMQ_HOST = "localhost"  # Use Docker service name
EXCHANGE_NAME = "order_delivery_exchange"
EXCHANGE_TYPE = "fanout"
ORDER_SERVICE_URL = "http://localhost:5003"  # Order microservice URL
PICKER_SERVICE_URL = "http://localhost:5001"  # Picker microservice URL

# Track active pickers and their socket IDs
active_pickers = {}
# Track orders waiting for pickup
pending_orders = {}

# =========================================================================
# Subscribe to RabbitMQ Exchange
# =========================================================================
def rabbitmq_listener():
    '''Setup RabbitMQ'''
    try:
        # Creates a RabbitMQ Exchange
        print(f"Connecting to RabbitMQ at {RABBITMQ_HOST}...")
        connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST))
        channel = connection.channel()
        channel.exchange_declare(exchange=EXCHANGE_NAME, exchange_type=EXCHANGE_TYPE)

        # Binds new queue to the Exchange
        result = channel.queue_declare(queue="assign_picker_queue", durable=True)
        queue_name = result.method.queue
        channel.queue_bind(exchange=EXCHANGE_NAME, queue=queue_name)
        print(f"RabbitMQ listener connected and bound to exchange {EXCHANGE_NAME}")

        # RabbitMQ Messaging Logic (when request is sent to rabbitMQ)
        def callback(ch, method, properties, body):
            try:
                message = json.loads(body)
                print(f"Received message from RabbitMQ: {message}")
                msg_type = message.get("type")
                
                # 3 types: Create new order, picker accepts order, order gets cancelled
                if msg_type == "new_order":
                    handle_new_order(message)
                elif msg_type == "picker_acceptance":
                    handle_picker_acceptance(message)
                elif msg_type == "order_cancelled":
                    handle_order_cancelled(message)
                else:
                    print(f"Unknown message type: {msg_type}")
            except Exception as e:
                print(f"Error processing RabbitMQ message: {str(e)}")

        # RabbitMQ Starts to run
        print(f"Starting to consume messages from queue {queue_name}")
        channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)
        channel.start_consuming()

    # Error Handling for RabbitMQ
    except Exception as e:
        print(f"RabbitMQ listener error: {str(e)}")
        time.sleep(5) # Try to reconnect after a delay
        threading.Thread(target=rabbitmq_listener).start()

# =========================================================================
# 2. Picker Accepting Order
# Picker accept -> patch -> remove order -> notify picker and cust
# =========================================================================
def handle_picker_acceptance(message):
    order_id = message.get("order_id")
    picker_id = message.get("picker_id")
    
    # Check if there is order_id and picker_id
    if not order_id or not picker_id:
        print("Invalid picker_acceptance message format")
        return
    
    # Start the process
    print(f"Processing picker acceptance: Picker {picker_id} accepted Order {order_id}")
    
    # Send PATCH Request to update order status
    try:
        response = requests.patch(
            f"{ORDER_SERVICE_URL}/orders/{order_id}/status",
            json={
                "order_status": "assigned",
                "picker_id": picker_id
            }
        )
        
        if response.status_code != 200:
            print(f"Failed to update order status: {response.text}")
            return
        
        order_data = response.json()
        print(f"Order {order_id} status updated: {order_data}")
    except Exception as e:
        print(f"Error updating order status: {str(e)}")
        return
    
    # Remove from pending orders since it's been accepted
    if order_id in pending_orders:
        print(f"Removing order {order_id} from pending orders (accepted by picker {picker_id})")
        order_data = pending_orders.pop(order_id)
    else:
        print(f"Order {order_id} not found in pending orders")
    
    # Notify all pickers that this order is taken
    socketio.emit("order_taken", {
        "order_id": order_id,
        "picker_id": picker_id,
        "status": "assigned"
    }, room="pickers")
    print(f"Notified all pickers that order {order_id} was taken by picker {picker_id}")
    
    # Notify the customer if they're connected
    customer_room = f"customer_{order_id}"
    socketio.emit("picker_update", {
        "order_id": order_id,
        "picker_id": picker_id,
        "status": "assigned"
    }, room=customer_room)
    print(f"Notified customer in room '{customer_room}' about picker assignment")

# =========================================================================
# 3. Handle new order
# =========================================================================
def handle_new_order(message):
    order_id = message.get("order_id")
    order_data = message.get("order_data")
    
    # If no order_id or order_data then invalid
    if not order_id or not order_data:
        print("Invalid new_order message format")
        return
    
    print(f"Adding order {order_id} to pending orders")
    # Store in pending orders
    pending_orders[order_id] = order_data
    
    # Broadcast to all active pickers
    socketio.emit("order_waiting", {
        "order_id": order_id,
        "status": "pending",
        "details": order_data
    }, room="pickers")
    
    print(f"Broadcasted new order {order_id} to pickers room")

# =========================================================================
# 4. Handle Order Cancellation
# =========================================================================
def handle_order_cancelled(message):
    """Handle an order cancellation"""
    order_id = message.get("order_id")
    
    if not order_id:
        print("Invalid order_cancelled message format")
        return
    
    # Remove from pending orders
    if order_id in pending_orders:
        print(f"Removing order {order_id} from pending orders (cancelled)")
        pending_orders.pop(order_id)
    else:
        print(f"Order {order_id} not found in pending orders (for cancellation)")
    
    # Notify all pickers
    socketio.emit("order_cancelled", {
        "order_id": order_id
    }, room="pickers")
    print(f"Notified all pickers that order {order_id} was cancelled")

# =========================================================================
# 5. Publish to RabbitMQ Exchange the message
# =========================================================================
def publish_to_rabbitmq(message):
    """Publish a message to the RabbitMQ exchange"""
    try:
        # Connects to the rabbitMQ exchange
        connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST))
        channel = connection.channel()
        channel.exchange_declare(exchange=EXCHANGE_NAME, exchange_type=EXCHANGE_TYPE)
        
        # publish the message
        channel.basic_publish(
            exchange=EXCHANGE_NAME,
            routing_key="",  # Fanout exchange ignores routing key
            body=json.dumps(message)
        )
        
        connection.close()
        print(f"Published message to RabbitMQ exchange '{EXCHANGE_NAME}'")
        return True
    except Exception as e:
        print(f"Error publishing to RabbitMQ: {str(e)}")
        return False

# =========================================================================
# 6. Start the RabbitMQ listener in a background thread
# =========================================================================
rabbitmq_thread = threading.Thread(target=rabbitmq_listener)
rabbitmq_thread.daemon = True
rabbitmq_thread.start()

# =========================================================================
# 7. create a new order endpoint
# =========================================================================
@app.route("/orders", methods=["POST"])
def create_order():
    """Create a new order and broadcast it to pickers"""
    try:
        print("Creating new order...")
        # Get order data from request
        order_data = request.get_json()
        print(f"Received order data: {order_data}")
        
        if not order_data:
            return jsonify({"error": "Missing order data"}), 400
            
        # Calls the ORDER MS to create a new order
        print(f"Sending to order service: {ORDER_SERVICE_URL}/orders")
        response = requests.post(f"{ORDER_SERVICE_URL}/orders", json=order_data)
        print(f"Order service response: {response.status_code}")
        
        if response.status_code != 201:
            print(f"Failed to create order: {response.text}")
            return jsonify({"error": "Failed to create order"}), response.status_code
            
        new_order = response.json()
        order_id = new_order.get("id")
        print(f"Order created with ID: {order_id}")
        
        # Stores the order data in the pending order dict
        pending_orders[order_id] = new_order
        print(f"Added order {order_id} to pending orders")
        
        # Broadcast the new order to pickers
        message = {
            "order_id": order_id,
            "order_data": new_order,
            "type": "new_order"
        }
        
        # Directly emit to the pickers room via Socket.IO
        socketio.emit(
            "order_waiting",
            {
                "order_id": order_id,
                "status": "pending",
                "details": new_order
            },
            room="pickers"
        )
        print(f"Directly emitted order_waiting event to pickers room")
        
        print(f"Publishing to RabbitMQ: {message}")
        publish_to_rabbitmq(message)
        
        return jsonify({
            "message": "Order created and broadcast to pickers",
            "order_id": order_id
        }), 201
    
    except Exception as e:
        print(f"Error in create_order: {str(e)}")
        return jsonify({"error": f"Failed to process order: {str(e)}"}), 500

# =========================================================================
# 8. create a picker accept endpoint
# =========================================================================
@app.route("/picker_accept", methods=["POST"])
def picker_accept():
    """Handle a picker accepting an order"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "Missing request data"}), 400
            
        order_id = data.get("order_id")
        picker_id = data.get("picker_id")
        
        if not order_id or not picker_id:
            return jsonify({"error": "Missing order_id or picker_id"}), 400
            
        # Publish the acceptance to RabbitMQ
        message = {
            "order_id": order_id,
            "picker_id": picker_id,
            "type": "picker_acceptance"
        }
        
        if publish_to_rabbitmq(message):
            # Let all the picker and customer know order is accepted
            handle_picker_acceptance(message)
            
            return jsonify({
                "message": "Order acceptance processed",
                "order_id": order_id,
                "picker_id": picker_id
            }), 200
        else:
            return jsonify({"error": "Failed to process order acceptance"}), 500
            
    except Exception as e:
        print(f"Error in picker_accept: {str(e)}")
        return jsonify({"error": f"Failed to process acceptance: {str(e)}"}), 500

# =========================================================================
# 9. Customer cancel order endpoint
# =========================================================================
@app.route("/orders/<order_id>/cancel", methods=["POST"])
def cancel_order(order_id):
    """Cancel an order"""
    try:
        # Update the order status in the order service
        response = requests.patch(
            f"{ORDER_SERVICE_URL}/orders/{order_id}/status",
            json={"order_status": "cancelled"}
        )
        
        if response.status_code != 200:
            return jsonify({"error": "Failed to update order status"}), response.status_code
            
        # Publish the cancellation to RabbitMQ
        message = {
            "order_id": order_id,
            "type": "order_cancelled"
        }
        
        if publish_to_rabbitmq(message):
            # Let the order be cancelled and notify customer and picker
            handle_order_cancelled(message)
            
            return jsonify({
                "message": "Order cancellation processed",
                "order_id": order_id
            }), 200
        else:
            return jsonify({"error": "Failed to process order cancellation"}), 500
            
    except Exception as e:
        print(f"Error in cancel_order: {str(e)}")
        return jsonify({"error": f"Failed to process cancellation: {str(e)}"}), 500

# =========================================================================
# 10. Endpoint to get pending orders for picker to see
# =========================================================================
@app.route("/debug/pending_orders", methods=["GET"])
def debug_pending_orders():
    """Return all pending orders (for debugging)"""
    return jsonify({
        "count": len(pending_orders),
        "orders": pending_orders
    })

# =========================================================================
# 11. Endpoint to get active pickers (Not that necessary)
# =========================================================================
@app.route("/debug/active_pickers", methods=["GET"])
def debug_active_pickers():
    """Return all active pickers (for debugging)"""
    return jsonify({
        "count": len(active_pickers),
        "pickers": active_pickers
    })


# =========================================================================
# 12. Websocket endpoints for UI to interact with
# =========================================================================
@socketio.on("connect")
def handle_connect():
    """Handle client connection"""
    print(f"Client connected: {request.sid}")

@socketio.on("disconnect")
def handle_disconnect():
    """Handle client disconnection"""
    print(f"Client disconnected: {request.sid}")
    
    # Remove from active pickers if this was a picker
    for picker_id, sid in list(active_pickers.items()):
        if sid == request.sid:
            print(f"Removing picker {picker_id} from active pickers")
            active_pickers.pop(picker_id)
            break

# =========================================================================
# 13. Register Picker and Customer and Test
# =========================================================================
@socketio.on("register_picker")
def register_picker(data):
    """Register a picker for receiving order notifications"""
    picker_id = data.get("picker_id")
    if not picker_id:
        return
    
    print(f"Picker {picker_id} registering with socket ID {request.sid}")
    
    # Add to active pickers
    active_pickers[picker_id] = request.sid
    
    # Join the pickers room to receive broadcasts
    join_room("pickers")
    print(f"Picker {picker_id} joined 'pickers' room")
    
    # Important: Send all currently pending orders to this newly connected picker
    print(f"Sending {len(pending_orders)} pending orders to picker {picker_id}")
    
    if pending_orders:
        for order_id, order_data in pending_orders.items():
            print(f"Sending pending order {order_id} to picker {picker_id}")
            # Send directly to this picker only (not broadcast to all)
            emit("order_waiting", {
                "order_id": order_id,
                "status": "pending",
                "details": order_data
            })
    else:
        print("No pending orders to send")
    
    print(f"Picker {picker_id} registration complete")

@socketio.on("register_customer")
def register_customer(data):
    """Register a customer for updates on their order"""
    customer_id = data.get("customer_id")
    order_id = data.get("order_id")
    
    if customer_id and order_id:
        customer_room = f"customer_{order_id}"
        join_room(customer_room)
        print(f"Customer {customer_id} joined room '{customer_room}' for order {order_id}")
        
        # Check if order is already assigned to a picker
        try:
            response = requests.get(f"{ORDER_SERVICE_URL}/orders/{order_id}")
            if response.status_code == 200:
                order_data = response.json()
                if order_data.get("order_status") == "assigned" and order_data.get("picker_id"):
                    # Send current picker information to the customer
                    emit("picker_update", {
                        "order_id": order_id,
                        "picker_id": order_data.get("picker_id"),
                        "status": "assigned"
                    })
                    print(f"Sent existing picker assignment to customer for order {order_id}")
        except Exception as e:
            print(f"Error checking order status: {str(e)}")

@socketio.on("test_event")
def handle_test_event(data):
    """Handle test event from client"""
    print(f"Received test event: {data}")
    emit("test_response", {"message": "Server received your test"})

# MAIN
if __name__ == "__main__":
    print("Starting Assign Picker service...")
    socketio.run(app, host="0.0.0.0", port=5005, debug=True)
</file>

<file path="composite/assign_picker.py">
from flask import Flask, request, jsonify
from flask_socketio import SocketIO, emit
from flask_cors import CORS
import pika
import json
import threading

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# RabbitMQ settings
RABBITMQ_HOST = "localhost"
EXCHANGE_NAME = "order_assignment_exchange"
EXCHANGE_TYPE = "fanout"


def rabbitmq_listener():
    """
    Background thread that listens for messages from RabbitMQ.
    It specifically looks for 'picker_acceptance' messages and then emits a WebSocket event.
    """
    connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST))
    channel = connection.channel()
    channel.exchange_declare(exchange=EXCHANGE_NAME, exchange_type=EXCHANGE_TYPE)

    # Declare a temporary queue for this listener
    result = channel.queue_declare(queue="", exclusive=True)
    queue_name = result.method.queue
    channel.queue_bind(exchange=EXCHANGE_NAME, queue=queue_name)

    def callback(ch, method, properties, body):
        message = json.loads(body)
        msg_type = message.get("type")
        if msg_type == "picker_acceptance":
            order_id = message.get("order_id")
            picker_id = message.get("picker_id")
            # Emit an event to notify the customer UI
            socketio.emit(
                "picker_update",
                {
                    "order_id": order_id,
                    "picker_id": picker_id,
                    "status": "Picker Accepted",
                },
                broadcast=True,
            )
        elif msg_type == "new_order":
            order_id = message.get("order_id")
            # Emit an event to notify the picker UI that an order is waiting
            socketio.emit(
                "order_waiting",
                {"order_id": order_id, "status": "Order waiting for acceptance"},
            )

    channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)
    channel.start_consuming()


# Start the RabbitMQ listener in a background thread.
threading.Thread(target=rabbitmq_listener, daemon=True).start()

@app.route("/assign_order", methods=["POST"])
def assign_order():
    """
    HTTP endpoint that the customer calls when placing a new order.
    It broadcasts the new order to available pickers via RabbitMQ.
    """
    data = request.get_json()
    if not data or "order_id" not in data:
        return jsonify({"error": "Missing order_id in request data"}), 400

    order_id = data["order_id"]

    try:
        connection = pika.BlockingConnection(
            pika.ConnectionParameters(host=RABBITMQ_HOST)
        )
        channel = connection.channel()
        channel.exchange_declare(exchange=EXCHANGE_NAME, exchange_type=EXCHANGE_TYPE)
        # Publish a message indicating a new order is available
        message = json.dumps({"order_id": order_id, "type": "new_order"})
        channel.basic_publish(exchange=EXCHANGE_NAME, routing_key="", body=message)
        connection.close()
    except Exception as e:
        return jsonify({"error": f"Failed to publish order message: {str(e)}"}), 500

    # Respond immediately to the customer
    return (
        jsonify({"message": "Order broadcast sent. Waiting for picker acceptance."}),
        200,
    )


@app.route("/picker_accept", methods=["POST"])
def picker_accept():
    """
    Endpoint for a picker to accept an order.
    Expects JSON with 'order_id' and 'picker_id'.
    Publishes a 'picker_acceptance' message to the exchange.
    """
    data = request.get_json()
    if not data or "order_id" not in data or "picker_id" not in data:
        return (
            jsonify({"error": "Missing required fields: order_id and picker_id"}),
            400,
        )

    order_id = data["order_id"]
    picker_id = data["picker_id"]

    try:
        connection = pika.BlockingConnection(
            pika.ConnectionParameters(host=RABBITMQ_HOST)
        )
        channel = connection.channel()
        channel.exchange_declare(exchange=EXCHANGE_NAME, exchange_type=EXCHANGE_TYPE)
        message = json.dumps(
            {"order_id": order_id, "picker_id": picker_id, "type": "picker_acceptance"}
        )
        channel.basic_publish(exchange=EXCHANGE_NAME, routing_key="", body=message)
        connection.close()
    except Exception as e:
        return jsonify({"error": f"Failed to publish acceptance: {str(e)}"}), 500

    return jsonify({"message": "Picker acceptance sent."}), 200


@socketio.on("connect")
def handle_connect():
    print("Customer connected via WebSocket.")


if __name__ == "__main__":
    # Run the service with SocketIO support on port 5005
    socketio.run(app, port=5005, debug=True)
</file>

<file path="composite/calc_payment.py">
from flask import Flask, request, jsonify
from flask_cors import CORS
import requests
import os
from datetime import datetime
import uuid

app = Flask(__name__)
CORS(app)

# Service URLs
CUSTOMER_SERVICE_URL = "http://customer-service:5000"
PAYMENT_SERVICE_URL = "http://payment-service:5004"

@app.route("/")
def home():
    return "Credit Management Composite Microservice"

@app.route("/credits/add", methods=['POST'])
def add_credits():
    data = request.get_json()
    
    # Validate required fields
    required_fields = ["customer_id", "amount"]
    if not all(field in data for field in required_fields):
        return jsonify({"error": "Missing required fields"}), 400
    
    customer_id = data["customer_id"]
    amount = data["amount"]
    
    # Validate amount is positive
    try:
        amount_value = float(amount)
        if amount_value <= 0:
            return jsonify({"error": "Amount must be greater than zero"}), 400
    except (ValueError, TypeError):
        return jsonify({"error": "Amount must be a valid number"}), 400
    
    try:
        # Step 1: Add credits to customer account
        customer_response = requests.post(
            f"{CUSTOMER_SERVICE_URL}/customers/{customer_id}/add-credits",
            json={"amount": amount_value}
        )
        
        if customer_response.status_code != 200:
            return jsonify({
                "error": "Failed to add credits to customer account",
                "details": customer_response.json()
            }), customer_response.status_code
        
        # Step 2: Create payment transaction
        payment_data = {
            "log_id": "hello",
            "customer_id": customer_id,
            "event_type": "Credit Top-Up",
            "event_details": f"Credits added: ${amount_value}",
            "payment_amount": amount_value,
            "payment_status": "Paid",
            "timestamp": datetime.now().isoformat()
        }
        
        try:
            payment_response = requests.post(
                f"{PAYMENT_SERVICE_URL}/payment",
                json=payment_data
            )
        except Exception as payment_error:
            return jsonify({"error": "Error creating payment transaction", "details": str(payment_error)}), 500
        
        if payment_response.status_code != 201:
            # If payment transaction fails, we should ideally roll back the customer credit update
            # This is a simplified version without rollback
            return jsonify({
                "error": "Failed to create payment transaction",
                "details": payment_response.json()
            }), payment_response.status_code
        
        # Return combined response
        return jsonify({
            "message": "Credits added successfully",
            "customer_update": customer_response.json(),
            "payment_transaction": payment_response.json()
        }), 201
        
    except Exception as e:
        return jsonify({"error": f"Error processing request: {str(e)}"}), 500

@app.route("/credits/use", methods=['POST'])
def use_credits():
    data = request.get_json()
    
    # Validate required fields
    required_fields = ["customer_id", "amount", "order_id"]
    if not all(field in data for field in required_fields):
        return jsonify({"error": "Missing required fields"}), 400
    
    customer_id = data["customer_id"]
    amount = data["amount"]
    order_id = data["order_id"]
    
    # Validate amount is positive
    try:
        amount_value = float(amount)
        if amount_value <= 0:
            return jsonify({"error": "Amount must be greater than zero"}), 400
    except (ValueError, TypeError):
        return jsonify({"error": "Amount must be a valid number"}), 400
    
    try:
        # Step 1: Check if customer has enough credits
        customer_response = requests.get(f"{CUSTOMER_SERVICE_URL}/customers/{customer_id}")
        
        if customer_response.status_code != 200:
            return jsonify({
                "error": "Failed to retrieve customer information",
                "details": customer_response.json()
            }), customer_response.status_code
        
        customer_data = customer_response.json()
        current_credits = customer_data.get("customer_credits", 0)
        
        if current_credits < amount_value:
            return jsonify({
                "error": "Insufficient credits",
                "current_credits": current_credits,
                "required_amount": amount_value
            }), 400
        
        # Step 2: Create payment transaction
        payment_data = {
            "log_id": f"payment_{uuid.uuid4()}",
            "order_id": order_id,
            "customer_id": customer_id,
            "event_type": "Payment",
            "event_details": f"Payment for order {order_id}",
            "payment_amount": amount_value,
            "payment_status": "Paid",
            "timestamp": datetime.now().isoformat()
        }
        
        payment_response = requests.post(
            f"{PAYMENT_SERVICE_URL}/payment",
            json=payment_data
        )
    
        
        if payment_response.status_code != 201:
            return jsonify({
                "error": "Failed to create payment transaction",
                "details": payment_response.json()
            }), payment_response.status_code
        
        # Step 3: Deduct credits from customer account
        # We'll create a dedicated endpoint for this in the customer service
        # For now, we'll simulate it by adding negative credits
        deduct_response = requests.post(
            f"{CUSTOMER_SERVICE_URL}/customers/{customer_id}/add-credits",
            json={"amount": -amount_value}
        )
        
        if deduct_response.status_code != 200:
            # If deducting credits fails, we should ideally roll back the payment transaction
            # This is a simplified version without rollback
            return jsonify({
                "error": "Failed to deduct credits from customer account",
                "details": deduct_response.json()
            }), deduct_response.status_code
        
        # Return combined response
        return jsonify({
            "message": "Payment processed successfully",
            "payment_transaction": payment_response.json(),
            "remaining_credits": current_credits - amount_value
        }), 201
        
    except Exception as e:
        return jsonify({"error": f"Error processing request: {str(e)}"}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5009, threaded=True)
</file>

<file path="composite/Dockerfile.calc_payment">
FROM python:3.12-slim

# Set working directory
WORKDIR /app

# Copy requirements first to leverage Docker cache
COPY composite_requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r composite_requirements.txt

# Copy application code
COPY ./composite/calc_payment.py /app/composite/
COPY ./composite/__init__.py /app/composite/
COPY ./models/ /app/models/
COPY .env.docker /app/.env
COPY firebase-adminsdk.json /app/firebase-adminsdk.json

# Set environment variables
ENV PYTHONPATH=/app
ENV FLASK_APP=/app/composite/calc_payment.py
ENV FLASK_RUN_HOST=0.0.0.0

# Expose the port that the service runs on
EXPOSE 5009

# Run the service
CMD ["python", "/app/composite/calc_payment.py"]
</file>

<file path="composite/requirements.txt">
annotated-types==0.7.0
bidict==0.23.1
blinker==1.9.0
cachecontrol==0.14.2
cachetools==5.5.2
certifi==2025.1.31
cffi==1.17.1
charset-normalizer==3.4.1
click==8.1.8
colorama==0.4.6
cryptography==44.0.2
dnspython==2.7.0
email-validator==2.2.0
firebase-admin==6.7.0
flask==3.1.0
flask-cors==5.0.1
flask-socketio==5.5.1
flask-sqlalchemy==3.1.1
google-api-core==2.24.2
google-api-python-client==2.166.0
google-auth==2.38.0
google-auth-httplib2==0.2.0
google-cloud-core==2.4.3
google-cloud-firestore==2.20.1
google-cloud-storage==3.1.0
google-crc32c==1.7.1
google-resumable-media==2.7.2
googleapis-common-protos==1.69.2
greenlet==3.1.1
grpcio==1.71.0
grpcio-status==1.71.0
h11==0.14.0
httplib2==0.22.0
idna==3.10
itsdangerous==2.2.0
jinja2==3.1.6
jsonify==0.5
markupsafe==3.0.2
msgpack==1.1.0
pika==1.3.2
proto-plus==1.26.1
protobuf==5.29.4
pyasn1==0.6.1
pyasn1-modules==0.4.1
pycparser==2.22
pydantic==2.10.6
pydantic-core==2.27.2
pyjwt==2.10.1
pyparsing==3.2.3
python-dotenv==1.1.0
python-engineio==4.11.2
python-socketio==5.12.1
requests==2.32.3
rsa==4.9
simple-websocket==1.1.0
sqlalchemy==2.0.39
typing-extensions==4.12.2
uritemplate==4.1.1
urllib3==2.3.0
werkzeug==3.1.3
wsproto==1.2.0
</file>

<file path="composite/updatelocation.py">
import os
import json
import firebase_admin
from firebase_admin import credentials, firestore
from flask import Flask, request, jsonify
import requests
import pika

app = Flask(__name__)



from flask_cors import CORS
CORS(app, resources={r"/*": {"origins": "http://localhost:5173"}})


# Initialize Firebase (if not already initialized)
try:
    if not firebase_admin._apps:
        cred = credentials.Certificate("../../firebase-adminsdk.json")
        firebase_admin.initialize_app(cred)
    db = firestore.client()
except Exception as e:
    print(f"Error initializing Firebase: {e}")

# RabbitMQ Configuration
RABBITMQ_HOST = 'localhost'  # Change if RabbitMQ is hosted elsewhere
QUEUE_NAME = 'picker_location_updates'

# Google Distance Matrix API Configuration
GOOGLE_API_KEY = 'AIzaSyDjH28uAStkeoEpvlVqtgt3OJk4_w74iRA'
GOOGLE_DISTANCE_MATRIX_URL = 'https://maps.googleapis.com/maps/api/distancematrix/json'

def send_to_picker_queue(picker_id, updated_location):
    """Safely send message to RabbitMQ with connection recovery"""
    try:
        connection = pika.BlockingConnection(
            pika.ConnectionParameters(host=RABBITMQ_HOST,
                                    heartbeat=600,
                                    blocked_connection_timeout=300))
        channel = connection.channel()
        channel.queue_declare(queue=QUEUE_NAME, durable=True)  # Persistent queue
        
        channel.basic_publish(
            exchange='',
            routing_key=QUEUE_NAME,
            body=json.dumps({
                "pickerID": picker_id,
                "updatedLocation": updated_location
            }),
            properties=pika.BasicProperties(
                delivery_mode=2  # Make message persistent
            ))
        connection.close()
        return True
    except Exception as e:
        print(f"RabbitMQ error: {str(e)}")
        return False


# Function to get route details from Google Distance Matrix API
def get_route_details(origin, destination):
    """Get route details between two locations using Google Distance Matrix API"""
    try:
        # Format coordinates for the API
        origin_str = f"{origin['lat']},{origin['lng']}"
        dest_str = f"{destination['lat']},{destination['lng']}"
        
        params = {
            'origins': origin_str,
            'destinations': dest_str,
            'key': GOOGLE_API_KEY,
        }
        response = requests.get(GOOGLE_DISTANCE_MATRIX_URL, params=params, timeout=10)
        if response.status_code == 200:
            data = response.json()
            return data['rows'][0]['elements'][0]  # Return first route details
        else:
            print(f"Error fetching route details: {response.text}")
            return None
    except Exception as e:
        print(f"Error in get_route_details: {str(e)}")
        return None

# Update Location Endpoint - Enhanced version that works with your existing order.py
@app.route('/update-location', methods=['POST'])
def update_location():
    try:
        # Parse request data
        data = request.json
        order_id = data.get('orderID')
        new_location = data.get('location')

        if not order_id or not new_location:
            return jsonify({"error": "orderID and location are required"}), 400

        # Validate location structure
        required_fields = ["address", "coordinates", "postal"]
        if not all(field in new_location for field in required_fields):
            return jsonify({"error": "Location must include address, coordinates, and postal code"}), 400
        
        coordinates = new_location.get("coordinates", {})
        if "lat" not in coordinates or "lng" not in coordinates:
            return jsonify({"error": "Coordinates must include both lat and lng"}), 400

        # Fetch the order from Firestore
        order_ref = db.collection('orders').document(str(order_id))
        order_doc = order_ref.get()

        if not order_doc.exists:
            return jsonify({"error": "Order not found"}), 404

        # Get order data
        order_data = order_doc.to_dict()
        
        # Check if order status allows location update
        allowed_statuses = ["pending", "assigned", "preparing"]
        if order_data.get('order_status') not in allowed_statuses:
            return jsonify({"error": "Cannot update location for orders that are already delivering, completed, or cancelled"}), 400

        # Update both location and order_location fields in Firestore
        update_fields = {"location": new_location}
        
        # Always update order_location field
        update_fields["order_location"] = f"{new_location['address']}, {new_location['postal']}"
            
        order_ref.update(update_fields)
        
        # Get pickerID from the order document if it exists
        picker_id = order_data.get('picker_id')
        picker_notified = False
        route_details = None
        
        # If a picker is assigned, notify them and calculate route
        if picker_id:
            # Get picker's current location (this would come from your picker service)
            # For now, we'll use a placeholder
            picker_location = {"lat": 1.2955, "lng": 103.8495}  # Default to SMU center
            
            # Calculate route using Google Distance Matrix API
            route_details = get_route_details(picker_location, new_location["coordinates"])
            
            # Notify picker via RabbitMQ
            picker_notified = send_to_picker_queue(picker_id, new_location)

        # Also update the order through the order microservice API for consistency
        try:
            order_service_url = os.environ.get('ORDER_SERVICE_URL', 'http://localhost:5003')
            response = requests.patch(
                f"{order_service_url}/orders/{order_id}/location",
                json={"location": new_location},
                timeout=5
            )
            
            if response.status_code != 200:
                print(f"Warning: Order service update failed: {response.text}")
                # Don't return error here - we've already updated Firestore directly
        except Exception as e:
            print(f"Warning: Error updating order service: {str(e)}")
            # Still continue since we updated Firestore directly

        return jsonify({
            "message": "Location updated successfully",
            "routeDetails": route_details,
            "pickerNotified": picker_notified,
            "orderID": order_id,
            "newLocation": new_location,
            "pickerID": picker_id,
            "order_location": update_fields["order_location"]
        }), 200

    except Exception as e:
        print(f"Error: {e}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5002)
</file>

<file path="models/customer_model.py">
from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class CustomerModel(BaseModel):
    firebase_uid: str = Field(..., min_length=1)
    customer_name: str = Field(..., min_length=1)
    customer_email: EmailStr
    customer_phone: int
    customer_credits: float
    
    # Optional fields that might be useful
    # address: Optional[str] = None
    # customer_notes: Optional[str] = None
    
    def to_dict(self):
        """Convert model to dictionary for Firestore storage"""
        return self.model_dump(exclude_none=True)
        
    @classmethod
    def from_dict(cls, data: dict):
        """Create model instance from Firestore document"""
        return cls(**data)
</file>

<file path="models/order_model.py">
from datetime import datetime
from enum import Enum
from typing import List, Optional
from pydantic import BaseModel, Field

class OrderStatus(str, Enum):
    pending = "pending"
    assigned = "assigned"
    preparing = "preparing"
    delivering = "delivering"
    completed = "completed"
    cancelled = "cancelled"

class OrderItemModel(BaseModel):
    order_item: str = Field(..., min_length=1)
    order_quantity: int = Field(..., gt=0)
    order_price: float = Field(..., gt=0)
    
    def to_dict(self):
        """Convert model to dictionary for Firestore storage"""
        return self.model_dump(exclude_none=True)
        
    @classmethod
    def from_dict(cls, data: dict):
        """Create model instance from Firestore document"""
        return cls(**data)

class OrderModel(BaseModel):
    customer_id: str = Field(..., min_length=1)
    picker_id: Optional[str] = None
    stall_id: str = Field(..., min_length=1)
    order_status: OrderStatus = Field(default=OrderStatus.pending)
    order_location: str = Field(..., min_length=1)
    order_start: datetime = Field(default_factory=datetime.now)
    order_completed: Optional[datetime] = None
    is_paid: bool = Field(default=False)
    order_items: List[OrderItemModel] = Field(..., min_items=1)
    
    def to_dict(self):
        """Convert model to dictionary for Firestore storage"""
        # Convert datetime objects to ISO strings for Firestore
        data = self.model_dump(exclude={"order_items"}, exclude_none=True)
        if "order_start" in data:
            data["order_start"] = data["order_start"].isoformat()
        if "order_completed" in data and data["order_completed"]:
            data["order_completed"] = data["order_completed"].isoformat()
        return data
        
    @classmethod
    def from_dict(cls, data: dict, items=None):
        """Create model instance from Firestore document and optional items list"""
        order_data = data.copy()
        
        # Convert ISO string dates back to datetime objects
        if "order_start" in order_data and isinstance(order_data["order_start"], str):
            order_data["order_start"] = datetime.fromisoformat(order_data["order_start"])
        if "order_completed" in order_data and isinstance(order_data["order_completed"], str):
            order_data["order_completed"] = datetime.fromisoformat(order_data["order_completed"])
        
        if items:
            order_data["order_items"] = items
        else:
            order_data["order_items"] = []
            
        return cls(**order_data)
</file>

<file path="models/picker_model.py">
from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class PickerModel(BaseModel):
    firebase_uid: str = Field(..., min_length=1)
    picker_name: str = Field(..., min_length=1)
    picker_email: EmailStr
    picker_phone: int
    is_available: bool = Field(default=True)
    
    # Optional fields you might want to add later
    # location: Optional[str] = None
    # rating: Optional[float] = Field(None, ge=0, le=5)
    
    def to_dict(self):
        """Convert model to dictionary for Firestore storage"""
        return self.model_dump(exclude_none=True)
        
    @classmethod
    def from_dict(cls, data: dict):
        """Create model instance from Firestore document"""
        return cls(**data)
</file>

<file path="models/stall_model.py">
from pydantic import BaseModel, Field
from typing import List, Optional

class MenuItemModel(BaseModel):
    food_name: str = Field(..., min_length=1)
    food_price: float = Field(..., gt=0)
    food_description: Optional[str] = None
    food_image: Optional[str] = None
    food_category: str
    
    
    def to_dict(self):
        """Convert model to dictionary for Firestore storage"""
        return self.model_dump(exclude_none=True)
        
    @classmethod
    def from_dict(cls, data: dict):
        """Create model instance from Firestore document"""
        return cls(**data)

class StallModel(BaseModel):
    stall_name: str = Field(..., min_length=1)
    stall_image: str = Field(..., min_length=1)
    stall_cover_image: Optional[str] = None
    stall_description: Optional[str] = None
    rating: float = Field(..., gt=0)
    review_count: int
    cuisines: Optional[List[str]]
    preparation_time_mins: int
    delivery_fee: float = Field(..., gt=0)
    stall_location: str = Field(..., min_length=1)
    is_promoted: bool
    menu: Optional[List[MenuItemModel]] = []
    
    def to_dict(self):
        """Convert model to dictionary for Firestore storage"""
        data = self.model_dump(exclude={"menu"}, exclude_none=True)
        return data
        
    @classmethod
    def from_dict(cls, data: dict, menu_items=None):
        """Create model instance from Firestore document and optional menu items"""
        stall_data = data.copy()
        if menu_items:
            stall_data["menu"] = menu_items
        return cls(**stall_data)
</file>

<file path="test/receive.py">
#!/usr/bin/env python
import pika, sys, os

def main():
    connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))
    channel = connection.channel()

    channel.queue_declare(queue='hello')

    def callback(ch, method, properties, body):
        print(f" [x] Received {body}")

    channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)

    print(' [*] Waiting for messages. To exit press CTRL+C')
    channel.start_consuming()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print('Interrupted')
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
</file>

<file path="test/send.py">
import pika

connection = pika.BlockingConnection(
    pika.ConnectionParameters(host='localhost'))
channel = connection.channel()

channel.queue_declare(queue='hello')

channel.basic_publish(exchange='', routing_key='hello', body='Hello World!')
print(" [x] Sent 'Hello World!'")
connection.close()
</file>

<file path=".env.docker">
FIREBASE_SERVICE_ACCOUNT_KEY_PATH=/app/firebase-adminsdk.json
RABBITMQ_HOST=rabbitmq
CUSTOMER_SERVICE_URL=http://customer-service:5000
PICKER_SERVICE_URL=http://picker-service:5001
STALL_SERVICE_URL=http://stall-service:5002
ORDER_SERVICE_URL=http://order-service:5003
</file>

<file path=".gitignore">
.venv
/venv
__pycache__
*.pyc
.env
firebase-adminsdk.json
</file>

<file path="atomic_requirements.txt">
flask==3.1.0
flask-cors==5.0.1
python-dotenv==1.1.0
firebase-admin==6.7.0
pydantic==2.10.6
email-validator==2.2.0
</file>

<file path="composite_requirements.txt">
flask==3.1.0
flask-cors==5.0.1
python-dotenv==1.1.0
firebase-admin==6.7.0
pydantic==2.10.6
email-validator==2.2.0
requests==2.32.3
</file>

<file path="customer.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Customer Order Interface</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 20px auto; padding: 20px; }
        .container { border: 1px solid #ddd; border-radius: 5px; padding: 20px; margin-bottom: 20px; }
        .message-container { border: 1px solid #ddd; padding: 10px; height: 300px; overflow-y: auto; margin-top: 10px; }
        button { padding: 10px 15px; margin: 5px 0; background-color: #4CAF50; color: white; border: none; cursor: pointer; border-radius: 4px; }
        button:hover { background-color: #45a049; }
        input, select, textarea { padding: 8px; margin: 5px 0; width: 100%; box-sizing: border-box; }
        label { font-weight: bold; }
        .status { padding: 10px; border-radius: 4px; margin: 10px 0; }
        .connected { background-color: #dff0d8; color: #3c763d; }
        .disconnected { background-color: #f2dede; color: #a94442; }
        .order-form { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .order-items { border: 1px solid #ddd; padding: 10px; margin-top: 10px; }
        .item-row { display: flex; gap: 10px; margin-bottom: 10px; }
        .item-row button { background-color: #f44336; }
    </style>
</head>
<body>
    <h1>Food Delivery - Customer Order Interface</h1>
    
    <div class="container">
        <h2>Connection Status</h2>
        <div id="status" class="status disconnected">Disconnected</div>
        <button id="connect">Connect</button>
        <button id="disconnect">Disconnect</button>
    </div>

    <div class="container">
        <h2>Create New Order</h2>
        <div class="order-form">
            <div>
                <label for="customer-id">Customer ID:</label>
                <input type="text" id="customer-id" placeholder="Enter your customer ID" required>
                
                <label for="stall-id">Stall ID:</label>
                <input type="text" id="stall-id" placeholder="Enter stall ID" required>
                
                <label for="order-location">Delivery Location:</label>
                <input type="text" id="order-location" placeholder="Enter delivery location" required>
                
                <div class="order-items">
                    <h3>Order Items</h3>
                    <div id="items-container"></div>
                    <button type="button" id="add-item">Add Item</button>
                </div>
            </div>
            <div>
                <div class="order-summary">
                    <h3>Order Summary</h3>
                    <div id="order-summary">
                        No items added yet
                    </div>
                    <p>Total: $<span id="order-total">0.00</span></p>
                </div>
                
                <div style="margin-top: 20px;">
                    <button id="create-order" style="width: 100%">Create Order</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Track Order</h2>
        <input type="text" id="track-order-id" placeholder="Enter order ID to track">
        <button id="track-order">Track This Order</button>
    </div>

    <div class="container">
        <h2>Messages & Updates</h2>
        <div class="message-container" id="messages"></div>
    </div>

    <script>
        let socket = null;
        let currentOrderId = null;
        let orderItems = [];
        const statusDiv = document.getElementById('status');
        const messagesDiv = document.getElementById('messages');
        const connectBtn = document.getElementById('connect');
        const disconnectBtn = document.getElementById('disconnect');
        const createOrderBtn = document.getElementById('create-order');
        const trackOrderBtn = document.getElementById('track-order');
        const addItemBtn = document.getElementById('add-item');
        const itemsContainer = document.getElementById('items-container');
        const orderSummary = document.getElementById('order-summary');
        const orderTotal = document.getElementById('order-total');

        function addMessage(msg) {
            const p = document.createElement('p');
            const timestamp = new Date().toLocaleTimeString();
            p.innerHTML = `<strong>${timestamp}</strong>: ${msg}`;
            messagesDiv.appendChild(p);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function updateConnectionStatus(connected) {
            if (connected) {
                statusDiv.textContent = 'Connected';
                statusDiv.className = 'status connected';
            } else {
                statusDiv.textContent = 'Disconnected';
                statusDiv.className = 'status disconnected';
            }
        }

        function addItemRow() {
            const itemId = Date.now(); // Unique ID for this item row
            const row = document.createElement('div');
            row.className = 'item-row';
            row.dataset.id = itemId;
            
            row.innerHTML = `
                <input type="text" placeholder="Item name" class="item-name" required>
                <input type="number" placeholder="Quantity" min="1" value="1" class="item-quantity" required>
                <input type="number" placeholder="Price" min="0.01" step="0.01" class="item-price" required>
                <button type="button" class="remove-item">✕</button>
            `;
            
            itemsContainer.appendChild(row);
            
            // Add event listener to remove button
            row.querySelector('.remove-item').addEventListener('click', function() {
                itemsContainer.removeChild(row);
                updateOrderSummary();
            });
            
            // Add event listeners to update summary when values change
            row.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', updateOrderSummary);
            });
        }

        function updateOrderSummary() {
            // Collect all item data
            const items = [];
            let total = 0;
            
            document.querySelectorAll('.item-row').forEach(row => {
                const nameInput = row.querySelector('.item-name');
                const quantityInput = row.querySelector('.item-quantity');
                const priceInput = row.querySelector('.item-price');
                
                const name = nameInput.value || 'Unnamed item';
                const quantity = parseInt(quantityInput.value) || 0;
                const price = parseFloat(priceInput.value) || 0;
                
                const itemTotal = quantity * price;
                total += itemTotal;
                
                items.push({
                    name,
                    quantity,
                    price,
                    total: itemTotal
                });
            });
            
            // Update the summary
            if (items.length === 0) {
                orderSummary.innerHTML = 'No items added yet';
            } else {
                orderSummary.innerHTML = items.map(item => 
                    `<p>${item.quantity}x ${item.name} @ $${item.price.toFixed(2)} = $${item.total.toFixed(2)}</p>`
                ).join('');
            }
            
            // Update the total
            orderTotal.textContent = total.toFixed(2);
            
            // Save items for order creation
            orderItems = items;
        }

        addItemBtn.addEventListener('click', addItemRow);

        connectBtn.addEventListener('click', () => {
            if (socket) {
                addMessage('Already connected.');
                return;
            }
            
            socket = io('http://localhost:5005');
            
            socket.on('connect', () => {
                updateConnectionStatus(true);
                addMessage('Connected to WebSocket server.');
            });
            
            socket.on('disconnect', () => {
                updateConnectionStatus(false);
                addMessage('Disconnected from server.');
                socket = null;
            });
            
            socket.on('picker_update', data => {
                addMessage(`<b>Order Update:</b> Order #${data.order_id} has been accepted by picker #${data.picker_id}. Status: ${data.status}`);
            });
        });

        disconnectBtn.addEventListener('click', () => {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
        });

        createOrderBtn.addEventListener('click', () => {
            const customerId = document.getElementById('customer-id').value.trim();
            const stallId = document.getElementById('stall-id').value.trim();
            const orderLocation = document.getElementById('order-location').value.trim();
            
            if (!customerId || !stallId || !orderLocation) {
                alert('Please fill in all required fields.');
                return;
            }
            
            if (orderItems.length === 0) {
                alert('Please add at least one item to your order.');
                return;
            }
            
            // Format order items according to the OrderItemModel
            const formattedItems = orderItems.map(item => ({
                order_item: item.name,
                order_quantity: item.quantity,
                order_price: item.price
            }));
            
            const orderData = {
                customer_id: customerId,
                stall_id: stallId,
                order_location: orderLocation,
                order_status: "pending",
                is_paid: false,
                order_items: formattedItems
            };
            
            addMessage('Creating order: ' + JSON.stringify(orderData));
            
            fetch('http://localhost:5005/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                addMessage('Order created! Order ID: ' + data.order_id);
                currentOrderId = data.order_id;
                
                // Register for updates on this order
                if (socket) {
                    socket.emit('register_customer', {
                        customer_id: customerId,
                        order_id: currentOrderId
                    });
                    addMessage('Registered for updates on this order.');
                }
            })
            .catch(err => addMessage('Error: ' + err.message));
        });

        trackOrderBtn.addEventListener('click', () => {
            const orderId = document.getElementById('track-order-id').value.trim();
            const customerId = document.getElementById('customer-id').value.trim();
            
            if (!orderId || !customerId) {
                alert('Please enter both order ID and customer ID.');
                return;
            }
            
            if (socket) {
                socket.emit('register_customer', {
                    customer_id: customerId,
                    order_id: orderId
                });
                addMessage(`Now tracking updates for order #${orderId}`);
            } else {
                addMessage('Please connect to the server first.');
            }
        });
        
        // Add an initial item row
        addItemRow();
    </script>
</body>
</html>
</file>

<file path="docker-compose.yml">
services:
  customer-service:
    build:
      context: .
      dockerfile: ./atomic/Dockerfile.customer
    ports:
      - "5000:5000"
    env_file:
      - .env.docker
    volumes:
      - ./firebase-adminsdk.json:/app/firebase-adminsdk.json
    networks:
      - esd-network
      
  picker-service:
    build:
      context: .
      dockerfile: ./atomic/Dockerfile.picker
    ports:
      - "5001:5001"
    env_file:
      - .env.docker
    volumes:
      - ./firebase-adminsdk.json:/app/firebase-adminsdk.json
    networks:
      - esd-network

  stall-service:
    build:
      context: .
      dockerfile: ./atomic/Dockerfile.stall
    ports:
      - "5002:5002"
    env_file:
      - .env.docker
    volumes:
      - ./firebase-adminsdk.json:/app/firebase-adminsdk.json
    networks:
      - esd-network
      
  order-service:
    build:
      context: .
      dockerfile: ./atomic/Dockerfile.order
    ports:
      - "5003:5003"
    env_file:
      - .env.docker
    volumes:
      - ./firebase-adminsdk.json:/app/firebase-adminsdk.json
    networks:
      - esd-network
      
  payment-service:
    build:
      context: .
      dockerfile: ./atomic/Dockerfile.payment
    ports:
      - "5004:5004"  # You can change the port as needed
    env_file:
      - .env.docker
    volumes:
      - ./firebase-adminsdk.json:/app/firebase-adminsdk.json
    networks:
      - esd-network

  calc-payment-service:
    build:
      context: .
      dockerfile: ./composite/Dockerfile.calc_payment
    ports:
      - "5009:5009"  # You can change the port as needed
    env_file:
      - .env.docker
    volumes:
      - ./firebase-adminsdk.json:/app/firebase-adminsdk.json
    networks:
      - esd-network

  # Add RabbitMQ for messaging between services
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
    networks:
      - esd-network

networks:
  esd-network:
    driver: bridge
</file>

<file path="firebase.json">
{
    "projects": {
        "default": "your-firebase-project-id"
    },
    "firestore": {
        "rules": "firestore.rules"
    },
    "hosting": {
        "public": "frontend/dist",
        "rewrites": [
            {
                "source": "/api/picker/**",
                "function": "pickerService"
            },
            {
                "source": "/api/customer/**",
                "function": "customerService"
            }
        ]
    },
    "functions": {
        "source": "backend/functions"
    }
}
</file>

<file path="package.json">
{
  "dependencies": {
    "cors": "^2.8.5"
  }
}
</file>

<file path="picker.html">
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Picker Interface</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
        }

        .container {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .message-container {
            border: 1px solid #ddd;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        button {
            padding: 10px 15px;
            margin: 5px 0;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }

        button:hover {
            background-color: #45a049;
        }

        input {
            padding: 8px;
            margin: 5px 0;
            width: 100%;
            box-sizing: border-box;
        }

        label {
            font-weight: bold;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .connected {
            background-color: #dff0d8;
            color: #3c763d;
        }

        .disconnected {
            background-color: #f2dede;
            color: #a94442;
        }

        #pending-orders {
            margin-top: 15px;
        }

        .order-card {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            background-color: #f9f9f9;
            position: relative;
        }

        .accept-btn {
            position: absolute;
            right: 10px;
            top: 10px;
        }

        .order-items {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        .item {
            margin-bottom: 5px;
            font-size: 14px;
        }

        .picker-controls {
            display: flex;
            gap: 10px;
        }
    </style>
</head>

<body>
    <h1>Food Delivery - Picker Interface</h1>

    <div class="container">
        <h2>Connection Status</h2>
        <div id="status" class="status disconnected">Disconnected</div>
        <button id="connect">Connect</button>
        <button id="disconnect">Disconnect</button>
    </div>

    <div class="container">
        <h2>Picker Information</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div>
                <label for="picker-id">Picker ID:</label>
                <input type="text" id="picker-id" placeholder="Enter your picker ID">

                <label for="picker-name">Name:</label>
                <input type="text" id="picker-name" placeholder="Your name">

                <label for="picker-email">Email:</label>
                <input type="email" id="picker-email" placeholder="Your email">
            </div>
            <div>
                <label for="picker-phone">Phone:</label>
                <input type="number" id="picker-phone" placeholder="Your phone number">

                <div style="margin-top: 10px;">
                    <label for="picker-availability">Available for orders:</label>
                    <input type="checkbox" id="picker-availability" checked>
                </div>

                <div class="picker-controls">
                    <button id="register-picker">Register as Picker</button>
                    <button id="create-picker" title="Create a new picker in the database">Create New Picker</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Available Orders</h2>
        <div id="pending-orders">
            <p>No pending orders available.</p>
        </div>
    </div>

    <div class="container">
        <h2>Messages & Updates</h2>
        <div class="message-container" id="messages"></div>
    </div>

    <script>
        let socket = null;
        const statusDiv = document.getElementById('status');
        const messagesDiv = document.getElementById('messages');
        const pendingOrdersDiv = document.getElementById('pending-orders');
        const connectBtn = document.getElementById('connect');
        const disconnectBtn = document.getElementById('disconnect');
        const registerPickerBtn = document.getElementById('register-picker');
        const createPickerBtn = document.getElementById('create-picker');
        const pickerIdInput = document.getElementById('picker-id');
        const pickerNameInput = document.getElementById('picker-name');
        const pickerEmailInput = document.getElementById('picker-email');
        const pickerPhoneInput = document.getElementById('picker-phone');
        const pickerAvailabilityInput = document.getElementById('picker-availability');

        // Track pending orders
        let pendingOrders = {};

        function addMessage(msg) {
            const p = document.createElement('p');
            const timestamp = new Date().toLocaleTimeString();
            p.innerHTML = `<strong>${timestamp}</strong>: ${msg}`;
            messagesDiv.appendChild(p);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function updateConnectionStatus(connected) {
            if (connected) {
                statusDiv.textContent = 'Connected';
                statusDiv.className = 'status connected';
            } else {
                statusDiv.textContent = 'Disconnected';
                statusDiv.className = 'status disconnected';
            }
        }

        function updatePendingOrdersDisplay() {
            pendingOrdersDiv.innerHTML = '';

            const orderIds = Object.keys(pendingOrders);

            if (orderIds.length === 0) {
                pendingOrdersDiv.innerHTML = '<p>No pending orders available.</p>';
                return;
            }

            orderIds.forEach(orderId => {
                const orderData = pendingOrders[orderId];
                const orderCard = document.createElement('div');
                orderCard.className = 'order-card';
                orderCard.id = `order-${orderId}`;

                let orderDetails = `<h3>Order #${orderId}</h3>`;

                if (orderData.details) {
                    const details = orderData.details;
                    orderDetails += `
                        <p><strong>Stall ID:</strong> ${details.stall_id || 'Not specified'}</p>
                        <p><strong>Delivery Location:</strong> ${details.order_location || 'Not specified'}</p>
                        <p><strong>Status:</strong> ${details.order_status || 'Pending'}</p>
                    `;

                    // Show order items if available
                    if (details.order_items && details.order_items.length > 0) {
                        orderDetails += `<div class="order-items"><h4>Items:</h4>`;
                        details.order_items.forEach(item => {
                            orderDetails += `
                                <div class="item">
                                    ${item.order_quantity}x ${item.order_item} 
                                    ($${item.order_price.toFixed(2)} each)
                                </div>
                            `;
                        });
                        orderDetails += `</div>`;
                    }
                }

                const acceptBtn = document.createElement('button');
                acceptBtn.textContent = 'Accept Order';
                acceptBtn.className = 'accept-btn';
                acceptBtn.onclick = () => acceptOrder(orderId);

                orderCard.innerHTML = orderDetails;
                orderCard.appendChild(acceptBtn);
                pendingOrdersDiv.appendChild(orderCard);
            });
        }

        function acceptOrder(orderId) {
            const pickerId = pickerIdInput.value.trim();

            if (!pickerId) {
                alert('Please enter your Picker ID first.');
                return;
            }

            fetch('http://localhost:5005/picker_accept', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ order_id: orderId, picker_id: pickerId })
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    addMessage(`Accepting order #${orderId}: ${JSON.stringify(data)}`);
                })
                .catch(err => addMessage(`Error accepting order: ${err.message}`));
        }

        // Create a new picker in the database
        createPickerBtn.addEventListener('click', () => {
            const name = pickerNameInput.value.trim();
            const email = pickerEmailInput.value.trim();
            const phone = pickerPhoneInput.value.trim();
            const isAvailable = pickerAvailabilityInput.checked;

            if (!name || !email || !phone) {
                alert('Please fill in all required picker information.');
                return;
            }

            // Create picker via the API
            fetch('http://localhost:5001/pickers', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    picker_name: name,
                    picker_email: email,
                    picker_phone: parseInt(phone),
                    is_available: isAvailable
                })
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    addMessage(`Picker created with ID: ${data.id}`);
                    pickerIdInput.value = data.id;
                })
                .catch(err => addMessage(`Error creating picker: ${err.message}`));
        });

        connectBtn.addEventListener('click', () => {
            if (socket) {
                addMessage('Already connected.');
                return;
            }

            socket = io('http://localhost:5005');

            socket.on('connect', () => {
                updateConnectionStatus(true);
                addMessage('Connected to WebSocket server.');
                console.log('Socket connected with ID:', socket.id);
            });

            socket.on('disconnect', () => {
                updateConnectionStatus(false);
                addMessage('Disconnected from server.');
                pendingOrders = {};
                updatePendingOrdersDisplay();
                socket = null;
            });

            // In picker.html, add more robust data handling:
            socket.on('order_waiting', data => {
                console.log('Received order_waiting event:', data);
                addMessage(`New order available: #${data.order_id}`);

                // Make sure data has the right structure
                if (!data.order_id) {
                    console.error('Missing order_id in data:', data);
                    return;
                }

                pendingOrders[data.order_id] = data;
                updatePendingOrdersDisplay();
            });

            socket.on('order_taken', data => {
                addMessage(`Order #${data.order_id} has been taken by picker #${data.picker_id}.`);
                delete pendingOrders[data.order_id];
                updatePendingOrdersDisplay();
            });

            socket.on('order_cancelled', data => {
                addMessage(`Order #${data.order_id} has been cancelled.`);
                delete pendingOrders[data.order_id];
                updatePendingOrdersDisplay();
            });
        });

        disconnectBtn.addEventListener('click', () => {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
        });

        registerPickerBtn.addEventListener('click', () => {
            const pickerId = pickerIdInput.value.trim();

            if (!pickerId) {
                alert('Please enter your Picker ID.');
                return;
            }

            if (!socket) {
                alert('Please connect to the server first.');
                return;
            }

            // Update availability if needed
            const isAvailable = pickerAvailabilityInput.checked;
            fetch(`http://localhost:5001/pickers/${pickerId}/availability`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ is_available: isAvailable })
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to update availability. Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(() => {
                    // Now register with the socket server
                    socket.emit('register_picker', { picker_id: pickerId });
                    addMessage(`Registered as Picker #${pickerId} (Available: ${isAvailable ? 'Yes' : 'No'})`);
                })
                .catch(err => {
                    addMessage(`Error updating availability: ${err.message}`);
                    // Still try to register with socket
                    socket.emit('register_picker', { picker_id: pickerId });
                    addMessage(`Registered as Picker #${pickerId}`);
                });
        });
    </script>
</body>

</html>
</file>

<file path="requirements.txt">
annotated-types==0.7.0
bidict==0.23.1
blinker==1.9.0
cachecontrol==0.14.2
cachetools==5.5.2
certifi==2025.1.31
cffi==1.17.1
charset-normalizer==3.4.1
click==8.1.8
colorama==0.4.6
cryptography==44.0.2
dnspython==2.7.0
email-validator==2.2.0
firebase-admin==6.7.0
flask==3.1.0
flask-cors==5.0.1
flask-socketio==5.5.1
flask-sqlalchemy==3.1.1
google-api-core==2.24.2
google-api-python-client==2.166.0
google-auth==2.38.0
google-auth-httplib2==0.2.0
google-cloud-core==2.4.3
google-cloud-firestore==2.20.1
google-cloud-storage==3.1.0
google-crc32c==1.7.1
google-resumable-media==2.7.2
googleapis-common-protos==1.69.2
greenlet==3.1.1
grpcio==1.71.0
grpcio-status==1.71.0
h11==0.14.0
httplib2==0.22.0
idna==3.10
itsdangerous==2.2.0
jinja2==3.1.6
jsonify==0.5
markupsafe==3.0.2
msgpack==1.1.0
pika==1.3.2
proto-plus==1.26.1
protobuf==5.29.4
pyasn1==0.6.1
pyasn1-modules==0.4.1
pycparser==2.22
pydantic==2.10.6
pydantic-core==2.27.2
pyjwt==2.10.1
pyparsing==3.2.3
python-dotenv==1.1.0
python-engineio==4.11.2
python-socketio==5.12.1
requests==2.32.3
rsa==4.9
simple-websocket==1.1.0
sqlalchemy==2.0.39
typing-extensions==4.12.2
uritemplate==4.1.1
urllib3==2.3.0
werkzeug==3.1.3
wsproto==1.2.0
</file>

</files>
